<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<!-- 
	Copyright (C) 2007, 2008, 2009, 2010, 2011. PARP Research Group.
	<http://perception.inf.um.es>
	University of Murcia, Spain.

	This file is part of the QVision library.

	QVision is free software: you can redistribute it and/or modify
	it under the terms of the GNU Lesser General Public License as
	published by the Free Software Foundation, version 3 of the License.

	QVision is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU Lesser General Public License for more details.

	You should have received a copy of the GNU Lesser General Public
	License along with QVision. If not, see <http://www.gnu.org/licenses/>.
-->

<html><head><meta http-equiv="content-Type" content="text/html;charset=UTF-8">
<title>QVision: Qt&#39;s Image, Video and Computer Vision Library</title>
<meta name="title" content="QVision" />
<meta name="dc.title" content="QVision" />
<meta name="url" content="http://perception.inf.um.es/QVision" />
<meta name="author" content="PARP Research Group - http://perception.inf.um.es" />
<meta name="revisit-after" content="30 DAYS"/>
<meta name="robots" content="index,follow"/>
<meta name="classification" content="*">
<meta name="rating" content="Safe For Kids">
<meta name="distribution" content="GLOBAL"/>
<meta name="description" content="Qt's Image, Video and Computer Vision Library"/>
<meta name="page-topic" content="Computer Vision research and prototype programming"/>
<meta name="geo.country" content="ES" />

<!--
Keywords:
By license:		open source, gnu, lgpl, gpl, free
By theme:		computer vision, image processing, robotics, programming, source, development
By usage:		library, toolkit, framework, prototype, application
By programming specs:	object oriented, c++, block programming, reusability, gui, graphical, parallel computing, high performance, GPU, prototyping
Interoperability with:	Qt, GSL, GNU Scientific library, OpenCV, CGAL, QWT, CUDA, mplayer, IPP, Intel Image Performance Primitives, blas, lapack
Functionallity:		image features, matrix algebra, projective geometry, mser, function minimization, function optimization, canny operator, harris operator, corner detection, performance evaluation, cpu usage, graphical interface
Main data-types:	matrix, vector, tensor, quaternion, image, polyline
Video sources:		webcam, camera, stream
Devices:		embedded, desktop computer, laptop, mini-laptop
Authors:		PARP research group. University of Murcia, Spain.
-->

<meta name="keywords" content="augmented reality, sfm, structure from motion, open source, gnu, lgpl, gpl, free, computer vision, image processing, robotics, programming, source, development, library, toolkit, framework, prototype, application, object oriented, c++, block programming, reusability, gui, graphical, parallel computing, high performance, GPU, prototyping, Qt, GSL, GNU Scientific library, OpenCV, CGAL, QWT, CUDA, mplayer, IPP, Intel Image Performance Primitives, blas, lapack, image features, matrix algebra, projective geometry, mser, function minimization, function optimization, canny operator, harris operator, corner detection, performance evaluation, cpu usage, graphical interface, matrix, vector, tensor, quaternion, image, polyline, webcam, camera, stream, embedded, desktop computer, laptop, mini-laptop, University of Murcia, Spain, PARP research group, vision por computador"/>
<meta http-equiv="keywords" content="augmented reality, sfm, structure from motion, open source, gnu, lgpl, gpl, free, computer vision, image processing, robotics, programming, source, development, library, toolkit, framework, prototype, application, object oriented, c++, block programming, reusability, gui, graphical, parallel computing, high performance, GPU, prototyping, Qt, GSL, GNU Scientific library, OpenCV, CGAL, QWT, CUDA, mplayer, IPP, Intel Image Performance Primitives, blas, lapack, image features, matrix algebra, projective geometry, mser, function minimization, function optimization, canny operator, harris operator, corner detection, performance evaluation, cpu usage, graphical interface, matrix, vector, tensor, quaternion, image, polyline, webcam, camera, stream, embedded, desktop computer, laptop, mini-laptop, University of Murcia, Spain, PARP research group, vision por computador"/>
<meta http-equiv="pragma" content="no-cache"/>
<meta http-equiv="title" content="QVision"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="tabs.css" rel="stylesheet" type="text/css" />
<link rel="shortcut icon" href="favicon.ico" />
</head><body>

<table width="100%"><tr>
	<td><a href="http://perception.inf.um.es/"><img src="parp.png" border="0" /> <big>PARP Research Group</big></a></td>
	<td align="right"><a href="http://www.um.es/"><big>Universidad de Murcia</big> <img src="um.png" border="0" /></a></td>
</tr></table>

<hr /><br />

<table width="95%" align="center"><tr><td>

<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <form id="FSearchBox" action="search.php" method="get">
            <img id="MSearchSelect" src="search/search.png" alt=""/>
            <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                   onfocus="searchBox.OnSearchFieldFocus(true)" 
                   onblur="searchBox.OnSearchFieldFocus(false)"/>
          </form>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<h1>src/qvblockprogramming/qvguiblocks/qvcanvas.cpp</h1><a href="qvcanvas_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> *      Copyright (C) 2007, 2008, 2009, 2010, 2011, 2012. PARP Research Group.</span>
<a name="l00003"></a>00003 <span class="comment"> *      &lt;http://perception.inf.um.es&gt;</span>
<a name="l00004"></a>00004 <span class="comment"> *      University of Murcia, Spain.</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> *      This file is part of the QVision library.</span>
<a name="l00007"></a>00007 <span class="comment"> *</span>
<a name="l00008"></a>00008 <span class="comment"> *      QVision is free software: you can redistribute it and/or modify</span>
<a name="l00009"></a>00009 <span class="comment"> *      it under the terms of the GNU Lesser General Public License as</span>
<a name="l00010"></a>00010 <span class="comment"> *      published by the Free Software Foundation, version 3 of the License.</span>
<a name="l00011"></a>00011 <span class="comment"> *</span>
<a name="l00012"></a>00012 <span class="comment"> *      QVision is distributed in the hope that it will be useful,</span>
<a name="l00013"></a>00013 <span class="comment"> *      but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00014"></a>00014 <span class="comment"> *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00015"></a>00015 <span class="comment"> *      GNU Lesser General Public License for more details.</span>
<a name="l00016"></a>00016 <span class="comment"> *</span>
<a name="l00017"></a>00017 <span class="comment"> *      You should have received a copy of the GNU Lesser General Public</span>
<a name="l00018"></a>00018 <span class="comment"> *      License along with QVision. If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<a name="l00019"></a>00019 <span class="comment"> */</span>
<a name="l00020"></a>00020 
<a name="l00024"></a>00024 
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;math.h&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;<a class="code" href="qvdefines_8h.html" title="File from the QVision library.">qvdefines.h</a>&gt;</span>
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;QMouseEvent&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;QPainter&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;QScrollArea&gt;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;QScrollBar&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;QGLWidget&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;QToolButton&gt;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;QStatusBar&gt;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;QHBoxLayout&gt;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &lt;QGridLayout&gt;</span>
<a name="l00038"></a>00038 
<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;math.h&gt;</span>
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 <span class="preprocessor">#include &lt;QVImage&gt;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &quot;<a class="code" href="qvcanvas_8h.html" title="File from the QVision library.">qvcanvas.h</a>&quot;</span>
<a name="l00043"></a>00043 
<a name="l00044"></a>00044 <span class="preprocessor">#ifdef QVQWT</span>
<a name="l00045"></a>00045 <span class="preprocessor"></span><span class="preprocessor">#include &lt;qwt_scale_widget.h&gt;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &lt;qwt_scale_engine.h&gt;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &lt;qwt_scale_div.h&gt;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#endif</span>
<a name="l00049"></a>00049 <span class="preprocessor"></span>
<a name="l00050"></a>00050 <span class="preprocessor">#include &lt;GL/glu.h&gt;</span>
<a name="l00051"></a>00051 
<a name="l00052"></a>00052 QList&lt;QVImageArea *&gt; image_areas;
<a name="l00053"></a>00053 
<a name="l00054"></a>00054 <span class="comment">// #ifndef DOXYGEN_IGNORE_THIS</span>
<a name="l00055"></a><a class="code" href="classQVPainter.html#ac3a7669110b0fa478eb28b19ad1f5014">00055</a> <span class="keywordtype">void</span> <a class="code" href="classQVPainter.html#ac3a7669110b0fa478eb28b19ad1f5014" title="Draws a QVImage&amp;lt;T,n&amp;gt; of any type T and size n in the corresponding QVImageCanvas...">QVPainter::drawQVImage</a>(<a class="code" href="classQVGenericImage.html" title="Base class for QVImage objects.">QVGenericImage</a> *image,<span class="keywordtype">bool</span> adaptSize,<span class="keywordtype">float</span> low,<span class="keywordtype">float</span> high)
<a name="l00056"></a>00056 {
<a name="l00057"></a>00057     imageArea-&gt;drawQVImage(image,adaptSize,low,high);
<a name="l00058"></a>00058 }
<a name="l00059"></a>00059 
<a name="l00060"></a>00060 
<a name="l00061"></a><a class="code" href="classQVPainter.html#af213d51b59f8ed1254adb8f2df8f4f98">00061</a> <span class="keywordtype">void</span> <a class="code" href="classQVPainter.html#af213d51b59f8ed1254adb8f2df8f4f98" title="Draws text in a given pixel position of the QVImageCanvas which does not scale with...">QVPainter::drawTextUnscaled</a>(<span class="keyword">const</span> QPointF &amp; position, <span class="keyword">const</span> QString &amp; text)
<a name="l00062"></a>00062 {
<a name="l00063"></a>00063     save();
<a name="l00064"></a>00064     resetMatrix();
<a name="l00065"></a>00065     translate(-imageArea-&gt;topLeft);
<a name="l00066"></a>00066     drawText(imageArea-&gt;zoom*position,text);
<a name="l00067"></a>00067     restore();
<a name="l00068"></a>00068 }
<a name="l00069"></a>00069 
<a name="l00070"></a><a class="code" href="classQVPainter.html#a80c883678ef165e3ab1bd4277b16a708">00070</a> <span class="keywordtype">void</span> <a class="code" href="classQVPainter.html#af213d51b59f8ed1254adb8f2df8f4f98" title="Draws text in a given pixel position of the QVImageCanvas which does not scale with...">QVPainter::drawTextUnscaled</a>(<span class="keyword">const</span> QPoint &amp; position, <span class="keyword">const</span> QString &amp; text)
<a name="l00071"></a>00071 {
<a name="l00072"></a>00072     save();
<a name="l00073"></a>00073     resetMatrix();
<a name="l00074"></a>00074     translate(-imageArea-&gt;topLeft);
<a name="l00075"></a>00075     drawText(imageArea-&gt;zoom*position,text);
<a name="l00076"></a>00076     restore();
<a name="l00077"></a>00077 }
<a name="l00078"></a>00078 
<a name="l00079"></a><a class="code" href="classQVPainter.html#a47388fef21cdf479232f806250421aad">00079</a> <span class="keywordtype">void</span> <a class="code" href="classQVPainter.html#af213d51b59f8ed1254adb8f2df8f4f98" title="Draws text in a given pixel position of the QVImageCanvas which does not scale with...">QVPainter::drawTextUnscaled</a>(<span class="keyword">const</span> QRectF &amp; rectangle, <span class="keywordtype">int</span> flags,
<a name="l00080"></a>00080                       <span class="keyword">const</span> QString &amp; text, QRectF * boundingRect)
<a name="l00081"></a>00081 {
<a name="l00082"></a>00082     save();
<a name="l00083"></a>00083     resetMatrix();
<a name="l00084"></a>00084     translate(-imageArea-&gt;topLeft);
<a name="l00085"></a>00085     drawText(QRectF(imageArea-&gt;zoom*rectangle.topLeft(),
<a name="l00086"></a>00086                     imageArea-&gt;zoom*rectangle.size()),flags,text,boundingRect);
<a name="l00087"></a>00087     <span class="keywordflow">if</span>(boundingRect != 0)
<a name="l00088"></a>00088         *boundingRect = QRectF(imageArea-&gt;zoom*boundingRect-&gt;topLeft(),
<a name="l00089"></a>00089                                imageArea-&gt;zoom*boundingRect-&gt;size());
<a name="l00090"></a>00090     restore();
<a name="l00091"></a>00091 }
<a name="l00092"></a>00092 
<a name="l00093"></a><a class="code" href="classQVPainter.html#a3973f25acbc04f1d8c44584726ce2750">00093</a> <span class="keywordtype">void</span> <a class="code" href="classQVPainter.html#af213d51b59f8ed1254adb8f2df8f4f98" title="Draws text in a given pixel position of the QVImageCanvas which does not scale with...">QVPainter::drawTextUnscaled</a>(<span class="keyword">const</span> QRect &amp; rectangle, <span class="keywordtype">int</span> flags,
<a name="l00094"></a>00094                       <span class="keyword">const</span> QString &amp; text, QRect * boundingRect)
<a name="l00095"></a>00095 {
<a name="l00096"></a>00096     save();
<a name="l00097"></a>00097     resetMatrix();
<a name="l00098"></a>00098     translate(-imageArea-&gt;topLeft);
<a name="l00099"></a>00099     drawText(QRect(imageArea-&gt;zoom*rectangle.topLeft(),
<a name="l00100"></a>00100                    imageArea-&gt;zoom*rectangle.size()),flags,text,boundingRect);
<a name="l00101"></a>00101     <span class="keywordflow">if</span>(boundingRect != 0)
<a name="l00102"></a>00102         *boundingRect = QRect(imageArea-&gt;zoom*boundingRect-&gt;topLeft(),
<a name="l00103"></a>00103                               imageArea-&gt;zoom*boundingRect-&gt;size());
<a name="l00104"></a>00104     restore();
<a name="l00105"></a>00105 }
<a name="l00106"></a>00106 
<a name="l00107"></a><a class="code" href="classQVPainter.html#a1c5a3b3c4733c928d5ced4ad12715082">00107</a> <span class="keywordtype">void</span> <a class="code" href="classQVPainter.html#af213d51b59f8ed1254adb8f2df8f4f98" title="Draws text in a given pixel position of the QVImageCanvas which does not scale with...">QVPainter::drawTextUnscaled</a>(<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <span class="keyword">const</span> QString &amp; text)
<a name="l00108"></a>00108 {
<a name="l00109"></a>00109     save();
<a name="l00110"></a>00110     resetMatrix();
<a name="l00111"></a>00111     translate(-imageArea-&gt;topLeft);
<a name="l00112"></a>00112     drawText(imageArea-&gt;zoom*x,imageArea-&gt;zoom*y,text);
<a name="l00113"></a>00113     restore();
<a name="l00114"></a>00114 }
<a name="l00115"></a>00115 
<a name="l00116"></a><a class="code" href="classQVPainter.html#a3342fcc0c7e9383e019386aedb268c80">00116</a> <span class="keywordtype">void</span> <a class="code" href="classQVPainter.html#af213d51b59f8ed1254adb8f2df8f4f98" title="Draws text in a given pixel position of the QVImageCanvas which does not scale with...">QVPainter::drawTextUnscaled</a>(<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height, <span class="keywordtype">int</span> flags,
<a name="l00117"></a>00117                       <span class="keyword">const</span> QString &amp; text, QRect * boundingRect)
<a name="l00118"></a>00118 {
<a name="l00119"></a>00119     save();
<a name="l00120"></a>00120     resetMatrix();
<a name="l00121"></a>00121     translate(-imageArea-&gt;topLeft);
<a name="l00122"></a>00122     drawText(imageArea-&gt;zoom*x,imageArea-&gt;zoom*y,imageArea-&gt;zoom*width,
<a name="l00123"></a>00123              imageArea-&gt;zoom*height,flags,text,boundingRect);
<a name="l00124"></a>00124     <span class="keywordflow">if</span>(boundingRect != 0)
<a name="l00125"></a>00125         *boundingRect = QRect(imageArea-&gt;zoom*boundingRect-&gt;topLeft(),
<a name="l00126"></a>00126                               imageArea-&gt;zoom*boundingRect-&gt;size());
<a name="l00127"></a>00127     restore();
<a name="l00128"></a>00128 }
<a name="l00129"></a>00129 
<a name="l00130"></a><a class="code" href="classQVPainter.html#ad8052d85738f12c62c6b26fcc924aac3">00130</a> <span class="keywordtype">void</span> <a class="code" href="classQVPainter.html#af213d51b59f8ed1254adb8f2df8f4f98" title="Draws text in a given pixel position of the QVImageCanvas which does not scale with...">QVPainter::drawTextUnscaled</a>(<span class="keyword">const</span> QRectF &amp; rectangle, <span class="keyword">const</span> QString &amp; text,
<a name="l00131"></a>00131                       <span class="keyword">const</span> QTextOption &amp; option)
<a name="l00132"></a>00132 {
<a name="l00133"></a>00133     save();
<a name="l00134"></a>00134     resetMatrix();
<a name="l00135"></a>00135     translate(-imageArea-&gt;topLeft);
<a name="l00136"></a>00136     drawText(QRectF(imageArea-&gt;zoom*rectangle.topLeft(),
<a name="l00137"></a>00137                     imageArea-&gt;zoom*rectangle.size()),text,option);
<a name="l00138"></a>00138     restore();
<a name="l00139"></a>00139 }
<a name="l00140"></a>00140 
<a name="l00141"></a>00141 
<a name="l00142"></a>00142 <span class="keywordtype">void</span> QVImageArea::initObject(<span class="keywordtype">int</span> w, <span class="keywordtype">int</span> h)
<a name="l00143"></a>00143 {
<a name="l00144"></a>00144     zoom = 1;
<a name="l00145"></a>00145     origwidth = w;
<a name="l00146"></a>00146     origheight = h;
<a name="l00147"></a>00147     topLeft = QPoint(0,0);
<a name="l00148"></a>00148     selRect = QRect();
<a name="l00149"></a>00149     zoomRect = QRect();
<a name="l00150"></a>00150     selPoly = <a class="code" href="classQVPolyline.html" title="Polyline representation.">QVPolyline</a>();
<a name="l00151"></a>00151     setAttribute(Qt::WA_NoSystemBackground);
<a name="l00152"></a>00152     setMouseTracking(TRUE);
<a name="l00153"></a>00153     setMinimumSize(qMin(w,max_zoom),qMin(h,max_zoom));
<a name="l00154"></a>00154     setMaximumSize(w,h);
<a name="l00155"></a>00155     resize(w,h);
<a name="l00156"></a>00156     mouseMode = NONE;
<a name="l00157"></a>00157     polyMode = LIST;
<a name="l00158"></a>00158     dragging = FALSE;
<a name="l00159"></a>00159     drawSel= TRUE;
<a name="l00160"></a>00160     emit newGeometry(origwidth,origheight,topLeft.x(),topLeft.y(),width(),height(),zoom);
<a name="l00161"></a>00161 }
<a name="l00162"></a>00162 
<a name="l00163"></a>00163 QVImageArea::QVImageArea(<span class="keywordtype">int</span> w, <span class="keywordtype">int</span> h,QWidget *parent)
<a name="l00164"></a>00164     : QGLWidget(QGLFormat(QGL::DoubleBuffer|QGL::NoDepthBuffer|
<a name="l00165"></a>00165                 QGL::DirectRendering|QGL::HasOverlay), parent), max_zoom(128)
<a name="l00166"></a>00166 {
<a name="l00167"></a>00167     initObject(w,h);
<a name="l00168"></a>00168 }
<a name="l00169"></a>00169 
<a name="l00170"></a>00170 QVImageArea::QVImageArea(<span class="keywordtype">int</span> w, <span class="keywordtype">int</span> h,QWidget *parent,QGLWidget *other)
<a name="l00171"></a>00171     : QGLWidget(parent,other), max_zoom(128)
<a name="l00172"></a>00172 {
<a name="l00173"></a>00173     initObject(w,h);
<a name="l00174"></a>00174 }
<a name="l00175"></a>00175 
<a name="l00176"></a>00176 <span class="keywordtype">void</span> QVImageArea::centerZoom(<span class="keywordtype">int</span> zoom)
<a name="l00177"></a>00177 {
<a name="l00178"></a>00178     <span class="keywordflow">if</span>((zoom != this-&gt;zoom) and (zoom &gt;= 1) and (zoom &lt;= max_zoom)) {
<a name="l00179"></a>00179         <span class="keywordtype">int</span> old_zoom = this-&gt;zoom;
<a name="l00180"></a>00180         this-&gt;zoom = zoom;
<a name="l00181"></a>00181         setMaximumSize(zoom*origwidth,zoom*origheight);
<a name="l00182"></a>00182         QPoint newTopLeft = zoom*(topLeft+QPoint(width(),height())/2)/old_zoom
<a name="l00183"></a>00183                             - QPoint(width(),height())/2;
<a name="l00184"></a>00184         <span class="keywordflow">if</span>(newTopLeft.x() &lt; 0)
<a name="l00185"></a>00185             newTopLeft.setX(0);
<a name="l00186"></a>00186         <span class="keywordflow">if</span>(newTopLeft.y() &lt; 0)
<a name="l00187"></a>00187             newTopLeft.setY(0);
<a name="l00188"></a>00188         <span class="keywordflow">if</span>(newTopLeft.x()+width() &gt; origwidth*zoom)
<a name="l00189"></a>00189             newTopLeft.setX(origwidth*zoom-width());
<a name="l00190"></a>00190         <span class="keywordflow">if</span>(newTopLeft.y()+height() &gt; origheight*zoom)
<a name="l00191"></a>00191             newTopLeft.setY(origheight*zoom-height());
<a name="l00192"></a>00192         topLeft = newTopLeft;
<a name="l00193"></a>00193         makeCurrent();
<a name="l00194"></a>00194         update();
<a name="l00195"></a>00195         emit newGeometry(origwidth,origheight,topLeft.x(),topLeft.y(),width(),height(),zoom);
<a name="l00196"></a>00196     }
<a name="l00197"></a>00197 }
<a name="l00198"></a>00198 
<a name="l00199"></a>00199 <span class="keywordtype">void</span> QVImageArea::resizeGL(<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height)
<a name="l00200"></a>00200 {
<a name="l00201"></a>00201     QPoint newTopLeft = topLeft,newBottomRight = topLeft+QPoint(width,height);
<a name="l00202"></a>00202     <span class="keywordflow">if</span>(newBottomRight.x() &gt; origwidth*zoom)
<a name="l00203"></a>00203         newTopLeft.setX(origwidth*zoom-width);
<a name="l00204"></a>00204     <span class="keywordflow">if</span>(newBottomRight.y() &gt; origheight*zoom)
<a name="l00205"></a>00205         newTopLeft.setY(origheight*zoom-height);
<a name="l00206"></a>00206     topLeft = newTopLeft;
<a name="l00207"></a>00207     makeCurrent();
<a name="l00208"></a>00208     update();
<a name="l00209"></a>00209     emit newGeometry(origwidth,origheight,topLeft.x(),topLeft.y(),width,height,zoom);
<a name="l00210"></a>00210 }
<a name="l00211"></a>00211 
<a name="l00212"></a>00212 
<a name="l00213"></a>00213 <span class="keywordtype">void</span> QVImageArea::wheelEvent(QWheelEvent *event)
<a name="l00214"></a>00214 {
<a name="l00215"></a>00215     <span class="keywordflow">if</span> (event-&gt;delta() &gt; 0) {
<a name="l00216"></a>00216         centerZoom(2*zoom);
<a name="l00217"></a>00217     } <span class="keywordflow">else</span> {
<a name="l00218"></a>00218         centerZoom(zoom/2);
<a name="l00219"></a>00219     }
<a name="l00220"></a>00220 }
<a name="l00221"></a>00221 
<a name="l00222"></a>00222 <span class="comment">// Auxiliary function to draw &#39;intuitive&#39; rectangles that draw themselves at the</span>
<a name="l00223"></a>00223 <span class="comment">// borders:</span>
<a name="l00224"></a>00224 QRectF QVImageArea::intuitiveRect(QRect rect)
<a name="l00225"></a>00225 {
<a name="l00226"></a>00226         <span class="comment">/*return QRectF(rect.x(),rect.y()+1.0/zoom,</span>
<a name="l00227"></a>00227 <span class="comment">                                  rect.width()-1.0/zoom,rect.height()-1.0/zoom);*/</span>
<a name="l00228"></a>00228     <span class="keywordflow">return</span> QRectF(rect.x(),rect.y(),rect.width()-1.0/zoom,rect.height()-1.0/zoom);
<a name="l00229"></a>00229 }
<a name="l00230"></a>00230 
<a name="l00231"></a>00231 
<a name="l00232"></a>00232 QRect QVImageArea::innerRect()
<a name="l00233"></a>00233 {
<a name="l00234"></a>00234     QPoint q1(static_cast&lt;int&gt;(ceilf(static_cast&lt;float&gt;(topLeft.x())/zoom)),
<a name="l00235"></a>00235                 static_cast&lt;int&gt;(ceilf(static_cast&lt;float&gt;(topLeft.y())/zoom))),
<a name="l00236"></a>00236             q2(static_cast&lt;int&gt;(floor(static_cast&lt;float&gt;((topLeft.x()+width()))/zoom)-1),
<a name="l00237"></a>00237                 (<span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(floor(static_cast&lt;float&gt;(topLeft.y()+height()))/zoom))-1);
<a name="l00238"></a>00238     <span class="keywordflow">return</span> QRect(q1,q2);
<a name="l00239"></a>00239 }
<a name="l00240"></a>00240 
<a name="l00241"></a>00241 QRect QVImageArea::outerRect()
<a name="l00242"></a>00242 {
<a name="l00243"></a>00243     QPoint q1(static_cast&lt;int&gt;(ceilf(static_cast&lt;float&gt;(topLeft.x())/zoom)-1),
<a name="l00244"></a>00244                 static_cast&lt;int&gt;(ceilf(static_cast&lt;float&gt;(topLeft.y())/zoom))-1),
<a name="l00245"></a>00245            q2(static_cast&lt;int&gt;(floor(static_cast&lt;float&gt;((topLeft.x()+width()))/zoom)),
<a name="l00246"></a>00246                 (<span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(floor(static_cast&lt;float&gt;(topLeft.y()+height()))/zoom)));
<a name="l00247"></a>00247 
<a name="l00248"></a>00248     <span class="keywordflow">return</span> QRect(q1,q2) &amp; QRect(0,0,origwidth,origheight);
<a name="l00249"></a>00249 }
<a name="l00250"></a>00250 
<a name="l00251"></a>00251 <span class="keywordtype">void</span> QVImageArea::paintEvent(QPaintEvent *event)
<a name="l00252"></a>00252 {
<a name="l00253"></a>00253     Q_UNUSED(event);
<a name="l00254"></a>00254 
<a name="l00255"></a>00255     painter = <span class="keyword">new</span> <a class="code" href="classQVPainter.html" title="Inherits from QPainter to allow versatile drawing on a QVImageCanvas object.">QVPainter</a>(<span class="keyword">this</span>);
<a name="l00256"></a>00256 
<a name="l00257"></a>00257     painter-&gt;begin(<span class="keyword">this</span>);
<a name="l00258"></a>00258     <span class="comment">//painter-&gt;setRenderHint(QPainter::TextAntialiasing);</span>
<a name="l00259"></a>00259 
<a name="l00260"></a>00260     painter-&gt;setViewport(0,0,width(),height());
<a name="l00261"></a>00261     painter-&gt;resetMatrix();
<a name="l00262"></a>00262     painter-&gt;translate(-topLeft);
<a name="l00263"></a>00263     painter-&gt;scale(zoom,zoom);
<a name="l00264"></a>00264 
<a name="l00265"></a>00265     <span class="comment">// Now we call the user painting function:</span>
<a name="l00266"></a>00266     QVCanvas *image_viewer = qobject_cast&lt;QVCanvas *&gt;(parent());
<a name="l00267"></a>00267     <span class="keywordflow">if</span>(image_viewer == 0) {
<a name="l00268"></a>00268         qFatal(<span class="stringliteral">&quot;Internal error: parent of QVImageArea must be a QVCanvas.&quot;</span>);
<a name="l00269"></a>00269     } <span class="keywordflow">else</span> {
<a name="l00270"></a>00270         glClearColor(0,0,1,0);
<a name="l00271"></a>00271         glClear(GL_COLOR_BUFFER_BIT); <span class="comment">// Blue background</span>
<a name="l00272"></a>00272         image_viewer-&gt;viewer();
<a name="l00273"></a>00273     }
<a name="l00274"></a>00274 
<a name="l00275"></a>00275     <span class="comment">// Now, we render the selection (red) and zoom (blue) rectangles, and selected points/polyline (green):</span>
<a name="l00276"></a>00276     <span class="keywordflow">if</span>(drawSel) {
<a name="l00277"></a>00277         <span class="keywordflow">if</span>(selRect != QRect()) {
<a name="l00278"></a>00278             painter-&gt;setPen(QColor(Qt::red));
<a name="l00279"></a>00279             <span class="comment">// Dirty trick for more intuitive behavior of rectangle in the borders</span>
<a name="l00280"></a>00280             <span class="comment">// of the window:</span>
<a name="l00281"></a>00281             painter-&gt;drawRect(intuitiveRect(selRect));
<a name="l00282"></a>00282         }
<a name="l00283"></a>00283         <span class="keywordflow">if</span>(zoomRect != QRect()) {
<a name="l00284"></a>00284             painter-&gt;setPen(QColor(Qt::blue));
<a name="l00285"></a>00285             <span class="comment">// Dirty trick for more intuitive behavior of rectangle in the borders</span>
<a name="l00286"></a>00286             <span class="comment">// of the window:</span>
<a name="l00287"></a>00287             painter-&gt;drawRect(intuitiveRect(zoomRect));
<a name="l00288"></a>00288         }
<a name="l00289"></a>00289         <span class="keywordflow">if</span>(selPoly != <a class="code" href="classQVPolyline.html" title="Polyline representation.">QVPolyline</a>()) {
<a name="l00290"></a>00290             painter-&gt;setPen(QColor(Qt::green));
<a name="l00291"></a>00291             QPointF pointoffset = (zoom==1?QPointF(0.0,0.0):QPointF(+0.5,+0.5));
<a name="l00292"></a>00292             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = selPoly.size()-1; i&gt;=0; i--){
<a name="l00293"></a>00293                 painter-&gt;drawLine(selPoly.at(i)+QPointF(-2.0,+0.0) + pointoffset,
<a name="l00294"></a>00294                           selPoly.at(i)+QPointF(+2.0,+0.0) + pointoffset);
<a name="l00295"></a>00295                 painter-&gt;drawLine(selPoly.at(i)+QPointF(+0.0,-2.0) + pointoffset,
<a name="l00296"></a>00296                           selPoly.at(i)+QPointF(+0.0,+2.0) + pointoffset);
<a name="l00297"></a>00297                 <span class="keywordflow">if</span>( (polyMode == LINE or polyMode == CLOSED) and (i!=0) )
<a name="l00298"></a>00298                 painter-&gt;drawLine(selPoly.at(i-1) + pointoffset,selPoly.at(i) + pointoffset);
<a name="l00299"></a>00299             }
<a name="l00300"></a>00300             <span class="keywordflow">if</span> (polyMode == CLOSED)
<a name="l00301"></a>00301                 painter-&gt;drawLine(selPoly.at(0) + pointoffset, selPoly.at(selPoly.size() -1) + pointoffset);
<a name="l00302"></a>00302         }
<a name="l00303"></a>00303     }
<a name="l00304"></a>00304     <span class="comment">// Finally, if zoom is big enough, draw numbers with pixel values:</span>
<a name="l00305"></a>00305     <span class="keywordflow">if</span>(zoom &gt;= 32) {
<a name="l00306"></a>00306         painter-&gt;setPen(QColor(Qt::green));
<a name="l00307"></a>00307         QRect outer = outerRect();
<a name="l00308"></a>00308         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=outer.y();j&lt;outer.y()+outer.height();j++) {
<a name="l00309"></a>00309             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=outer.x();i&lt;outer.x()+outer.width();i++) {
<a name="l00310"></a>00310                 <span class="keywordflow">if</span>(not imageList.isEmpty()) {
<a name="l00311"></a>00311                     QString value_string;
<a name="l00312"></a>00312                     <span class="keywordtype">int</span> k;
<a name="l00313"></a>00313                     <span class="keywordflow">for</span>(k=0;k&lt;imageList.size();k++) {
<a name="l00314"></a>00314                         QRect img_rect = QRect(imageList[k]-&gt;getAnchor()+imageList[k]-&gt;getROI().topLeft(),
<a name="l00315"></a>00315                               QSize(imageList[k]-&gt;getROI().width(),imageList[k]-&gt;getROI().height()));
<a name="l00316"></a>00316                         <span class="keywordflow">if</span>(i&gt;=img_rect.left() and i&lt;=img_rect.right() and j&gt;=img_rect.top() and j&lt;=img_rect.bottom()) {
<a name="l00317"></a>00317                             <span class="comment">//value_string = QString(&quot;-%1-&quot;).arg(k);</span>
<a name="l00319"></a>00319 <span class="comment"></span>                            <span class="keywordflow">if</span>(imageList[k]-&gt;isCompatibleWith(<span class="stringliteral">&quot;QVImage&lt;uChar,1&gt;&quot;</span>)) {
<a name="l00320"></a>00320                                 <span class="keywordflow">if</span>(zoom &gt;= 32) {
<a name="l00321"></a>00321                                     value_string =  QString(<span class="stringliteral">&quot;%1&quot;</span>).arg((*(<a class="code" href="classQVImage.html">QVImage&lt;uChar,1&gt;</a>*)imageList[k])(i-img_rect.topLeft().x()+imageList[k]-&gt;getROI().topLeft().x(),j-img_rect.topLeft().y()+imageList[k]-&gt;getROI().topLeft().y()));
<a name="l00322"></a>00322                                 }
<a name="l00323"></a>00323                             }
<a name="l00324"></a>00324                             <span class="keywordflow">else</span> <span class="keywordflow">if</span>(imageList[k]-&gt;isCompatibleWith(<span class="stringliteral">&quot;QVImage&lt;uShort,1&gt;&quot;</span>)) {
<a name="l00325"></a>00325                                 <span class="keywordflow">if</span>(zoom &gt;= 64) {
<a name="l00326"></a>00326                                     value_string =  QString(<span class="stringliteral">&quot;%1&quot;</span>).arg((*(<a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;uShort,1&gt;</a>*)imageList[k])(i-img_rect.topLeft().x()+imageList[k]-&gt;getROI().topLeft().x(),j-img_rect.topLeft().y()+imageList[k]-&gt;getROI().topLeft().y()));
<a name="l00327"></a>00327                                 }
<a name="l00328"></a>00328                             }
<a name="l00329"></a>00329                             <span class="keywordflow">else</span> <span class="keywordflow">if</span>(imageList[k]-&gt;isCompatibleWith(<span class="stringliteral">&quot;QVImage&lt;sShort,1&gt;&quot;</span>)) {
<a name="l00330"></a>00330                                 <span class="keywordflow">if</span>(zoom &gt;= 64) {
<a name="l00331"></a>00331                                     value_string =  QString(<span class="stringliteral">&quot;%1&quot;</span>).arg((*(<a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;sShort,1&gt;</a>*)imageList[k])(i-img_rect.topLeft().x()+imageList[k]-&gt;getROI().topLeft().x(),j-img_rect.topLeft().y()+imageList[k]-&gt;getROI().topLeft().y()));
<a name="l00332"></a>00332                                 }
<a name="l00333"></a>00333                             }
<a name="l00334"></a>00334                             <span class="keywordflow">else</span> <span class="keywordflow">if</span>(imageList[k]-&gt;isCompatibleWith(<span class="stringliteral">&quot;QVImage&lt;sInt,1&gt;&quot;</span>)) {
<a name="l00335"></a>00335                                 <span class="keywordflow">if</span>(zoom &gt;= 64) {
<a name="l00336"></a>00336                                     value_string =  QString(<span class="stringliteral">&quot;%1&quot;</span>).arg((*(<a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;sInt,1&gt;</a>*)imageList[k])(i-img_rect.topLeft().x()+imageList[k]-&gt;getROI().topLeft().x(),j-img_rect.topLeft().y()+imageList[k]-&gt;getROI().topLeft().y()));
<a name="l00337"></a>00337                                 }
<a name="l00338"></a>00338                             }
<a name="l00339"></a>00339                             <span class="keywordflow">else</span> <span class="keywordflow">if</span>(imageList[k]-&gt;isCompatibleWith(<span class="stringliteral">&quot;QVImage&lt;sFloat,1&gt;&quot;</span>)) {
<a name="l00340"></a>00340                                 <span class="keywordflow">if</span>(zoom &gt;= 64) {
<a name="l00341"></a>00341                                     value_string =  QString(<span class="stringliteral">&quot;%1&quot;</span>).arg((*(<a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;sFloat,1&gt;</a>*)imageList[k])(i-img_rect.topLeft().x()+imageList[k]-&gt;getROI().topLeft().x(),j-img_rect.topLeft().y()+imageList[k]-&gt;getROI().topLeft().y()));
<a name="l00342"></a>00342                                 }
<a name="l00343"></a>00343                             }
<a name="l00344"></a>00344                             <span class="keywordflow">else</span> <span class="keywordflow">if</span>(imageList[k]-&gt;isCompatibleWith(<span class="stringliteral">&quot;QVImage&lt;uChar,3&gt;&quot;</span>)) {
<a name="l00345"></a>00345                                 <span class="keywordtype">int</span> red,green,blue;
<a name="l00346"></a>00346                                 <span class="keywordflow">if</span>(zoom &gt;= 64) {
<a name="l00347"></a>00347                                     red = (*(<a class="code" href="classQVImage.html">QVImage&lt;uChar,3&gt;</a>*)imageList[k])(i-img_rect.topLeft().x()+imageList[k]-&gt;getROI().topLeft().x(),j-img_rect.topLeft().y()+imageList[k]-&gt;getROI().topLeft().y(),0);
<a name="l00348"></a>00348                                     green = (*(<a class="code" href="classQVImage.html">QVImage&lt;uChar,3&gt;</a>*)imageList[k])(i-img_rect.topLeft().x()+imageList[k]-&gt;getROI().topLeft().x(),j-img_rect.topLeft().y()+imageList[k]-&gt;getROI().topLeft().y(),1);
<a name="l00349"></a>00349                                     blue = (*(<a class="code" href="classQVImage.html">QVImage&lt;uChar,3&gt;</a>*)imageList[k])(i-img_rect.topLeft().x()+imageList[k]-&gt;getROI().topLeft().x(),j-img_rect.topLeft().y()+imageList[k]-&gt;getROI().topLeft().y(),2);
<a name="l00350"></a>00350                                     value_string =  QString(<span class="stringliteral">&quot;R:%1\nG:%2\nB:%3&quot;</span>).arg(red).arg(green).arg(blue);
<a name="l00351"></a>00351                                 }
<a name="l00352"></a>00352                             }
<a name="l00353"></a>00353                             <span class="keywordflow">else</span> <span class="keywordflow">if</span>(imageList[k]-&gt;isCompatibleWith(<span class="stringliteral">&quot;QVImage&lt;uShort,3&gt;&quot;</span>)) {
<a name="l00354"></a>00354                                 <span class="keywordtype">int</span> red,green,blue;
<a name="l00355"></a>00355                                 <span class="keywordflow">if</span>(zoom &gt;= 64) {
<a name="l00356"></a>00356                                     red = (*(<a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;uShort,3&gt;</a>*)imageList[k])(i-img_rect.topLeft().x()+imageList[k]-&gt;getROI().topLeft().x(),j-img_rect.topLeft().y()+imageList[k]-&gt;getROI().topLeft().y(),0);
<a name="l00357"></a>00357                                     green = (*(<a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;uShort,3&gt;</a>*)imageList[k])(i-img_rect.topLeft().x()+imageList[k]-&gt;getROI().topLeft().x(),j-img_rect.topLeft().y()+imageList[k]-&gt;getROI().topLeft().y(),1);
<a name="l00358"></a>00358                                     blue = (*(<a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;uShort,3&gt;</a>*)imageList[k])(i-img_rect.topLeft().x()+imageList[k]-&gt;getROI().topLeft().x(),j-img_rect.topLeft().y()+imageList[k]-&gt;getROI().topLeft().y(),2);
<a name="l00359"></a>00359                                     value_string =  QString(<span class="stringliteral">&quot;R:%1\nG:%2\nB:%3&quot;</span>).arg(red).arg(green).arg(blue);
<a name="l00360"></a>00360                                 }
<a name="l00361"></a>00361                             }
<a name="l00362"></a>00362                             <span class="keywordflow">else</span> <span class="keywordflow">if</span>(imageList[k]-&gt;isCompatibleWith(<span class="stringliteral">&quot;QVImage&lt;sShort,3&gt;&quot;</span>)) {
<a name="l00363"></a>00363                                 <span class="keywordtype">int</span> red,green,blue;
<a name="l00364"></a>00364                                 <span class="keywordflow">if</span>(zoom &gt;= 64) {
<a name="l00365"></a>00365                                     red = (*(<a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;sShort,3&gt;</a>*)imageList[k])(i-img_rect.topLeft().x()+imageList[k]-&gt;getROI().topLeft().x(),j-img_rect.topLeft().y()+imageList[k]-&gt;getROI().topLeft().y(),0);
<a name="l00366"></a>00366                                     green = (*(<a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;sShort,3&gt;</a>*)imageList[k])(i-img_rect.topLeft().x()+imageList[k]-&gt;getROI().topLeft().x(),j-img_rect.topLeft().y()+imageList[k]-&gt;getROI().topLeft().y(),1);
<a name="l00367"></a>00367                                     blue = (*(<a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;sShort,3&gt;</a>*)imageList[k])(i-img_rect.topLeft().x()+imageList[k]-&gt;getROI().topLeft().x(),j-img_rect.topLeft().y()+imageList[k]-&gt;getROI().topLeft().y(),2);
<a name="l00368"></a>00368                                     value_string =  QString(<span class="stringliteral">&quot;R:%1\nG:%2\nB:%3&quot;</span>).arg(red).arg(green).arg(blue);
<a name="l00369"></a>00369                                 }
<a name="l00370"></a>00370                             }
<a name="l00371"></a>00371                             <span class="keywordflow">else</span> <span class="keywordflow">if</span>(imageList[k]-&gt;isCompatibleWith(<span class="stringliteral">&quot;QVImage&lt;sInt,3&gt;&quot;</span>)) {
<a name="l00372"></a>00372                                 <span class="keywordtype">int</span> red,green,blue;
<a name="l00373"></a>00373                                 <span class="keywordflow">if</span>(zoom &gt;= 64) {
<a name="l00374"></a>00374                                     red = (*(<a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;sInt,3&gt;</a>*)imageList[k])(i-img_rect.topLeft().x()+imageList[k]-&gt;getROI().topLeft().x(),j-img_rect.topLeft().y()+imageList[k]-&gt;getROI().topLeft().y(),0);
<a name="l00375"></a>00375                                     green = (*(<a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;sInt,3&gt;</a>*)imageList[k])(i-img_rect.topLeft().x()+imageList[k]-&gt;getROI().topLeft().x(),j-img_rect.topLeft().y()+imageList[k]-&gt;getROI().topLeft().y(),1);
<a name="l00376"></a>00376                                     blue = (*(<a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;sInt,3&gt;</a>*)imageList[k])(i-img_rect.topLeft().x()+imageList[k]-&gt;getROI().topLeft().x(),j-img_rect.topLeft().y()+imageList[k]-&gt;getROI().topLeft().y(),2);
<a name="l00377"></a>00377                                     value_string =  QString(<span class="stringliteral">&quot;R:%1\nG:%2\nB:%3&quot;</span>).arg(red).arg(green).arg(blue);
<a name="l00378"></a>00378                                 }
<a name="l00379"></a>00379                             }
<a name="l00380"></a>00380                             <span class="keywordflow">else</span> <span class="keywordflow">if</span>(imageList[k]-&gt;isCompatibleWith(<span class="stringliteral">&quot;QVImage&lt;sFloat,3&gt;&quot;</span>)) {
<a name="l00381"></a>00381                                 <span class="keywordtype">float</span> red,green,blue;
<a name="l00382"></a>00382                                 <span class="keywordflow">if</span>(zoom &gt;= 64) {
<a name="l00383"></a>00383                                     red = (*(<a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;sFloat,3&gt;</a>*)imageList[k])(i-img_rect.topLeft().x()+imageList[k]-&gt;getROI().topLeft().x(),j-img_rect.topLeft().y()+imageList[k]-&gt;getROI().topLeft().y(),0);
<a name="l00384"></a>00384                                     green = (*(<a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;sFloat,3&gt;</a>*)imageList[k])(i-img_rect.topLeft().x()+imageList[k]-&gt;getROI().topLeft().x(),j-img_rect.topLeft().y()+imageList[k]-&gt;getROI().topLeft().y(),1);
<a name="l00385"></a>00385                                     blue = (*(<a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;sFloat,3&gt;</a>*)imageList[k])(i-img_rect.topLeft().x()+imageList[k]-&gt;getROI().topLeft().x(),j-img_rect.topLeft().y()+imageList[k]-&gt;getROI().topLeft().y(),2);
<a name="l00386"></a>00386                                     value_string =  QString(<span class="stringliteral">&quot;R:%1\nG:%2\nB:%3&quot;</span>).arg(red).arg(green).arg(blue);
<a name="l00387"></a>00387                                 }
<a name="l00388"></a>00388                             }
<a name="l00389"></a>00389                             <span class="keywordflow">else</span> {
<a name="l00390"></a>00390                                 <span class="comment">// alternate code for that type of image ...</span>
<a name="l00391"></a>00391                                 qFatal(<span class="stringliteral">&quot;Type of QVGenericImage still not supported in paintEvent&quot;</span>);
<a name="l00392"></a>00392                             }
<a name="l00393"></a>00393                             <span class="keywordflow">break</span>;
<a name="l00394"></a>00394                         }
<a name="l00395"></a>00395                     }
<a name="l00396"></a>00396                     <span class="keywordflow">if</span>(k==imageList.size()) {
<a name="l00397"></a>00397                         value_string = QString(<span class="stringliteral">&quot;X&quot;</span>);
<a name="l00398"></a>00398                     }
<a name="l00399"></a>00399 
<a name="l00400"></a>00400                     <span class="comment">/* Alternative 1 (renderText):</span>
<a name="l00401"></a>00401 <span class="comment">                    renderText((i*zoom-topLeft.x()), ((j+1)*zoom-topLeft.y()),</span>
<a name="l00402"></a>00402 <span class="comment">                               value_string);*/</span>
<a name="l00403"></a>00403 
<a name="l00404"></a>00404                     <span class="comment">/* Alternative 2 (drawText with painter manipulation):*/</span>
<a name="l00405"></a>00405                     <span class="comment">/*painter-&gt;resetMatrix();</span>
<a name="l00406"></a>00406 <span class="comment">                    painter-&gt;translate(-topLeft);</span>
<a name="l00407"></a>00407 <span class="comment">                    painter-&gt;drawText(</span>
<a name="l00408"></a>00408 <span class="comment">                        QRect(zoom*QPoint(i,j),zoom*QPoint(i+1,j+1)),</span>
<a name="l00409"></a>00409 <span class="comment">                                  Qt::AlignCenter|Qt::TextDontClip,value_string);</span>
<a name="l00410"></a>00410 <span class="comment">                    painter-&gt;scale(zoom,zoom);*/</span>
<a name="l00411"></a>00411 
<a name="l00412"></a>00412                     <span class="comment">/* Alternative 3 (drawTextUnscaled, with QRectF):*/</span>
<a name="l00413"></a>00413                     <span class="comment">/*painter-&gt;drawTextUnscaled(</span>
<a name="l00414"></a>00414 <span class="comment">                        QRectF(QPointF(i,j),QSize(1,1)),</span>
<a name="l00415"></a>00415 <span class="comment">                              Qt::AlignCenter|Qt::TextDontClip,value_string);*/</span>
<a name="l00416"></a>00416 
<a name="l00417"></a>00417                     <span class="comment">/* Alternative 4 (drawTextUnscaled, with QRect): */</span>
<a name="l00418"></a>00418                     <span class="comment">// OJO, (!) error de QT (poco importante) en construcci√≥n de</span>
<a name="l00419"></a>00419                     <span class="comment">// rectangulos del tipo QRect(QPoint(x,y),QPoint(x+1,y+1)).</span>
<a name="l00420"></a>00420                     painter-&gt;drawTextUnscaled(
<a name="l00421"></a>00421                         QRect(QPoint(i,j),QSize(1,1)),
<a name="l00422"></a>00422                               Qt::AlignCenter|Qt::TextDontClip,value_string);
<a name="l00423"></a>00423                 }
<a name="l00424"></a>00424             }
<a name="l00425"></a>00425         }
<a name="l00426"></a>00426     }
<a name="l00427"></a>00427 
<a name="l00428"></a>00428     <span class="comment">// End of painting:</span>
<a name="l00429"></a>00429     painter-&gt;end();
<a name="l00430"></a>00430     <span class="keyword">delete</span> painter;
<a name="l00431"></a>00431 
<a name="l00432"></a>00432     <span class="comment">//imageList.clear();</span>
<a name="l00433"></a>00433     <span class="keywordflow">while</span> (!imageList.isEmpty())
<a name="l00434"></a>00434          <span class="keyword">delete</span> imageList.takeFirst();
<a name="l00435"></a>00435 }
<a name="l00436"></a>00436 
<a name="l00437"></a>00437 <span class="keywordtype">void</span> QVImageArea::resizeImageArea(<span class="keywordtype">int</span> w,<span class="keywordtype">int</span> h)
<a name="l00438"></a>00438 {
<a name="l00439"></a>00439     <span class="keywordflow">if</span>(w != origwidth or h != origheight) {
<a name="l00440"></a>00440         zoom = 1;
<a name="l00441"></a>00441         origwidth = w;
<a name="l00442"></a>00442         origheight = h;
<a name="l00443"></a>00443         topLeft = QPoint(0,0);
<a name="l00444"></a>00444         selRect = QRect();
<a name="l00445"></a>00445         zoomRect = QRect();
<a name="l00446"></a>00446         selPoly = <a class="code" href="classQVPolyline.html" title="Polyline representation.">QVPolyline</a>();
<a name="l00447"></a>00447         setMinimumSize(qMin(w,max_zoom),qMin(h,max_zoom));
<a name="l00448"></a>00448         setMaximumSize(w,h);
<a name="l00449"></a>00449         resize(w,h);
<a name="l00450"></a>00450         emit newGeometry(origwidth,origheight,topLeft.x(),topLeft.y(),width(),height(),zoom);
<a name="l00451"></a>00451     }
<a name="l00452"></a>00452 }
<a name="l00453"></a>00453 
<a name="l00454"></a>00454 <span class="keywordtype">void</span> QVImageArea::drawQVImage(<a class="code" href="classQVGenericImage.html" title="Base class for QVImage objects.">QVGenericImage</a> *image,<span class="keywordtype">bool</span> adaptSize,<span class="keywordtype">float</span> low, <span class="keywordtype">float</span> high)
<a name="l00455"></a>00455 {
<a name="l00456"></a>00456 
<a name="l00457"></a>00457     <a class="code" href="classQVGenericImage.html" title="Base class for QVImage objects.">QVGenericImage</a> *imagecopy=NULL;
<a name="l00458"></a>00458     <span class="keywordflow">if</span>(image-&gt;<a class="code" href="classQVGenericImage.html#a21b9bc211bcb5b0694ecdad16f1e5d59" title="Check whether an image is compatible in type with another image, provided its type...">isCompatibleWith</a>(<span class="stringliteral">&quot;QVImage&lt;uChar,1&gt;&quot;</span>)) {
<a name="l00459"></a>00459         imagecopy = <span class="keyword">new</span> <a class="code" href="classQVImage.html">QVImage&lt;uChar,1&gt;</a>;
<a name="l00460"></a>00460         *(<span class="keyword">dynamic_cast&lt;</span><a class="code" href="classQVImage.html">QVImage&lt;uChar,1&gt;</a>*<span class="keyword">&gt;</span>(imagecopy)) = *(<span class="keyword">dynamic_cast&lt;</span><a class="code" href="classQVImage.html">QVImage&lt;uChar,1&gt;</a>*<span class="keyword">&gt;</span>(image));
<a name="l00461"></a>00461     }
<a name="l00462"></a>00462     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(image-&gt;<a class="code" href="classQVGenericImage.html#a21b9bc211bcb5b0694ecdad16f1e5d59" title="Check whether an image is compatible in type with another image, provided its type...">isCompatibleWith</a>(<span class="stringliteral">&quot;QVImage&lt;uShort,1&gt;&quot;</span>)) {
<a name="l00463"></a>00463         imagecopy = <span class="keyword">new</span> <a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;uShort,1&gt;</a>;
<a name="l00464"></a>00464         *(<span class="keyword">dynamic_cast&lt;</span><a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;uShort,1&gt;</a>*<span class="keyword">&gt;</span>(imagecopy)) = *(<span class="keyword">dynamic_cast&lt;</span><a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;uShort,1&gt;</a>*<span class="keyword">&gt;</span>(image));
<a name="l00465"></a>00465     }
<a name="l00466"></a>00466     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(image-&gt;<a class="code" href="classQVGenericImage.html#a21b9bc211bcb5b0694ecdad16f1e5d59" title="Check whether an image is compatible in type with another image, provided its type...">isCompatibleWith</a>(<span class="stringliteral">&quot;QVImage&lt;sShort,1&gt;&quot;</span>)) {
<a name="l00467"></a>00467         imagecopy = <span class="keyword">new</span> <a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;sShort,1&gt;</a>;
<a name="l00468"></a>00468         *(<span class="keyword">dynamic_cast&lt;</span><a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;sShort,1&gt;</a>*<span class="keyword">&gt;</span>(imagecopy)) = *(<span class="keyword">dynamic_cast&lt;</span><a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;sShort,1&gt;</a>*<span class="keyword">&gt;</span>(image));
<a name="l00469"></a>00469     }
<a name="l00470"></a>00470     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(image-&gt;<a class="code" href="classQVGenericImage.html#a21b9bc211bcb5b0694ecdad16f1e5d59" title="Check whether an image is compatible in type with another image, provided its type...">isCompatibleWith</a>(<span class="stringliteral">&quot;QVImage&lt;sInt,1&gt;&quot;</span>)) {
<a name="l00471"></a>00471         imagecopy = <span class="keyword">new</span> <a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;sInt,1&gt;</a>;
<a name="l00472"></a>00472         *(<span class="keyword">dynamic_cast&lt;</span><a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;sInt,1&gt;</a>*<span class="keyword">&gt;</span>(imagecopy)) = *(<span class="keyword">dynamic_cast&lt;</span><a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;sInt,1&gt;</a>*<span class="keyword">&gt;</span>(image));
<a name="l00473"></a>00473     }
<a name="l00474"></a>00474     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(image-&gt;<a class="code" href="classQVGenericImage.html#a21b9bc211bcb5b0694ecdad16f1e5d59" title="Check whether an image is compatible in type with another image, provided its type...">isCompatibleWith</a>(<span class="stringliteral">&quot;QVImage&lt;sFloat,1&gt;&quot;</span>)) {
<a name="l00475"></a>00475         imagecopy = <span class="keyword">new</span> <a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;sFloat,1&gt;</a>;
<a name="l00476"></a>00476         *(<span class="keyword">dynamic_cast&lt;</span><a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;sFloat,1&gt;</a>*<span class="keyword">&gt;</span>(imagecopy)) = *(<span class="keyword">dynamic_cast&lt;</span><a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;sFloat,1&gt;</a>*<span class="keyword">&gt;</span>(image));
<a name="l00477"></a>00477     }
<a name="l00478"></a>00478     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(image-&gt;<a class="code" href="classQVGenericImage.html#a21b9bc211bcb5b0694ecdad16f1e5d59" title="Check whether an image is compatible in type with another image, provided its type...">isCompatibleWith</a>(<span class="stringliteral">&quot;QVImage&lt;uChar,3&gt;&quot;</span>)) {
<a name="l00479"></a>00479         imagecopy = <span class="keyword">new</span> <a class="code" href="classQVImage.html">QVImage&lt;uChar,3&gt;</a>;
<a name="l00480"></a>00480         *(<span class="keyword">dynamic_cast&lt;</span><a class="code" href="classQVImage.html">QVImage&lt;uChar,3&gt;</a>*<span class="keyword">&gt;</span>(imagecopy)) = *(<span class="keyword">dynamic_cast&lt;</span><a class="code" href="classQVImage.html">QVImage&lt;uChar,3&gt;</a>*<span class="keyword">&gt;</span>(image));
<a name="l00481"></a>00481     }
<a name="l00482"></a>00482     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(image-&gt;<a class="code" href="classQVGenericImage.html#a21b9bc211bcb5b0694ecdad16f1e5d59" title="Check whether an image is compatible in type with another image, provided its type...">isCompatibleWith</a>(<span class="stringliteral">&quot;QVImage&lt;uShort,3&gt;&quot;</span>)) {
<a name="l00483"></a>00483         imagecopy = <span class="keyword">new</span> <a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;uShort,3&gt;</a>;
<a name="l00484"></a>00484         *(<span class="keyword">dynamic_cast&lt;</span><a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;uShort,3&gt;</a>*<span class="keyword">&gt;</span>(imagecopy)) = *(<span class="keyword">dynamic_cast&lt;</span><a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;uShort,3&gt;</a>*<span class="keyword">&gt;</span>(image));
<a name="l00485"></a>00485     }
<a name="l00486"></a>00486     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(image-&gt;<a class="code" href="classQVGenericImage.html#a21b9bc211bcb5b0694ecdad16f1e5d59" title="Check whether an image is compatible in type with another image, provided its type...">isCompatibleWith</a>(<span class="stringliteral">&quot;QVImage&lt;sShort,3&gt;&quot;</span>)) {
<a name="l00487"></a>00487                 imagecopy = <span class="keyword">new</span> <a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;sShort,3&gt;</a>;
<a name="l00488"></a>00488         *(<span class="keyword">dynamic_cast&lt;</span><a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;sShort,3&gt;</a>*<span class="keyword">&gt;</span>(imagecopy)) = *(<span class="keyword">dynamic_cast&lt;</span><a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;sShort,3&gt;</a>*<span class="keyword">&gt;</span>(image));
<a name="l00489"></a>00489     }
<a name="l00490"></a>00490     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(image-&gt;<a class="code" href="classQVGenericImage.html#a21b9bc211bcb5b0694ecdad16f1e5d59" title="Check whether an image is compatible in type with another image, provided its type...">isCompatibleWith</a>(<span class="stringliteral">&quot;QVImage&lt;sInt,3&gt;&quot;</span>)) {
<a name="l00491"></a>00491         imagecopy = <span class="keyword">new</span> <a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;sInt,3&gt;</a>;
<a name="l00492"></a>00492         *(<span class="keyword">dynamic_cast&lt;</span><a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;sInt,3&gt;</a>*<span class="keyword">&gt;</span>(imagecopy)) = *(<span class="keyword">dynamic_cast&lt;</span><a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;sInt,3&gt;</a>*<span class="keyword">&gt;</span>(image));
<a name="l00493"></a>00493     }
<a name="l00494"></a>00494     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(image-&gt;<a class="code" href="classQVGenericImage.html#a21b9bc211bcb5b0694ecdad16f1e5d59" title="Check whether an image is compatible in type with another image, provided its type...">isCompatibleWith</a>(<span class="stringliteral">&quot;QVImage&lt;sFloat,3&gt;&quot;</span>)) {
<a name="l00495"></a>00495         imagecopy = <span class="keyword">new</span> <a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;sFloat,3&gt;</a>;
<a name="l00496"></a>00496         *(<span class="keyword">dynamic_cast&lt;</span><a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;sFloat,3&gt;</a>*<span class="keyword">&gt;</span>(imagecopy)) = *(<span class="keyword">dynamic_cast&lt;</span><a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;sFloat,3&gt;</a>*<span class="keyword">&gt;</span>(image));
<a name="l00497"></a>00497     }
<a name="l00498"></a>00498     <span class="keywordflow">else</span> {
<a name="l00499"></a>00499         <span class="comment">// alternate code for that type of image ...</span>
<a name="l00500"></a>00500         qFatal(<span class="stringliteral">&quot;Type of QVGenericImage still not supported in drawQVImage&quot;</span>);
<a name="l00501"></a>00501     }
<a name="l00502"></a>00502 
<a name="l00503"></a>00503     <span class="comment">// Image to the top of the stack (front of the list)</span>
<a name="l00504"></a>00504     imageList.push_front(imagecopy);
<a name="l00505"></a>00505 
<a name="l00506"></a>00506 
<a name="l00508"></a>00508     <span class="keywordflow">if</span>(adaptSize) {
<a name="l00509"></a>00509         this-&gt;resizeImageArea(image-&gt;<a class="code" href="classQVGenericImage.html#a9fede2a177fed58d69d9d13e93cd38b6" title="Obtains actual anchor point for the image.">getAnchor</a>().x()+image-&gt;<a class="code" href="classQVGenericImage.html#a55132f8ba36904516dcf384039c670e4" title="Method for obtaining actual region of interest for image.">getROI</a>().x()+image-&gt;<a class="code" href="classQVGenericImage.html#a55132f8ba36904516dcf384039c670e4" title="Method for obtaining actual region of interest for image.">getROI</a>().width(),image-&gt;<a class="code" href="classQVGenericImage.html#a9fede2a177fed58d69d9d13e93cd38b6" title="Obtains actual anchor point for the image.">getAnchor</a>().y()+image-&gt;<a class="code" href="classQVGenericImage.html#a55132f8ba36904516dcf384039c670e4" title="Method for obtaining actual region of interest for image.">getROI</a>().y()+image-&gt;<a class="code" href="classQVGenericImage.html#a55132f8ba36904516dcf384039c670e4" title="Method for obtaining actual region of interest for image.">getROI</a>().height());
<a name="l00510"></a>00510     }
<a name="l00511"></a>00511 
<a name="l00512"></a>00512     <span class="comment">// Push the current OpenGL projection and model-view matrices onto their</span>
<a name="l00513"></a>00513     <span class="comment">// respective stacks:</span>
<a name="l00514"></a>00514     glPushAttrib(GL_ALL_ATTRIB_BITS);
<a name="l00515"></a>00515     glPushClientAttrib(GL_ALL_ATTRIB_BITS);
<a name="l00516"></a>00516     glMatrixMode(GL_PROJECTION);
<a name="l00517"></a>00517     glPushMatrix();
<a name="l00518"></a>00518     glMatrixMode(GL_MODELVIEW);
<a name="l00519"></a>00519     glPushMatrix();
<a name="l00520"></a>00520 
<a name="l00521"></a>00521     <span class="comment">// Set the correct viewport and perspective and model transformation</span>
<a name="l00522"></a>00522     <span class="comment">// for native OpenGL calls:</span>
<a name="l00523"></a>00523     glViewport(0,0,width(),height());
<a name="l00524"></a>00524     glMatrixMode(GL_PROJECTION);
<a name="l00525"></a>00525     glLoadIdentity();
<a name="l00526"></a>00526     glOrtho(topLeft.x(),topLeft.x()+width(),
<a name="l00527"></a>00527             topLeft.y()+height(),topLeft.y(),-1,1);
<a name="l00528"></a>00528     glMatrixMode(GL_MODELVIEW);
<a name="l00529"></a>00529     glLoadIdentity();
<a name="l00530"></a>00530 
<a name="l00531"></a>00531     <span class="comment">// Intersection of current window viewport and image rectangles:</span>
<a name="l00532"></a>00532     QRect final_rect,outer_rect = outerRect(),
<a name="l00533"></a>00533           img_rect = QRect(imagecopy-&gt;<a class="code" href="classQVGenericImage.html#a9fede2a177fed58d69d9d13e93cd38b6" title="Obtains actual anchor point for the image.">getAnchor</a>()+imagecopy-&gt;<a class="code" href="classQVGenericImage.html#a55132f8ba36904516dcf384039c670e4" title="Method for obtaining actual region of interest for image.">getROI</a>().topLeft(),
<a name="l00534"></a>00534                           QSize(imagecopy-&gt;<a class="code" href="classQVGenericImage.html#a55132f8ba36904516dcf384039c670e4" title="Method for obtaining actual region of interest for image.">getROI</a>().width(),imagecopy-&gt;<a class="code" href="classQVGenericImage.html#a55132f8ba36904516dcf384039c670e4" title="Method for obtaining actual region of interest for image.">getROI</a>().height()));
<a name="l00535"></a>00535     final_rect = outer_rect &amp; img_rect;
<a name="l00536"></a>00536 
<a name="l00537"></a>00537     <span class="comment">// Now, render the image using OpenGL calls:</span>
<a name="l00538"></a>00538 
<a name="l00539"></a>00539     <span class="comment">// First, WHERE to draw...</span>
<a name="l00540"></a>00540     QPoint where,dirty; <span class="comment">// Dirty trick for offset (bitmap trick).</span>
<a name="l00541"></a>00541     <span class="keywordflow">if</span>(outer_rect.topLeft().x() &gt;= img_rect.topLeft().x()) {
<a name="l00542"></a>00542         where.setX(outer_rect.topLeft().x());
<a name="l00543"></a>00543         dirty.setX(1);
<a name="l00544"></a>00544     } <span class="keywordflow">else</span> {
<a name="l00545"></a>00545         where.setX(img_rect.topLeft().x());
<a name="l00546"></a>00546         dirty.setX(0);
<a name="l00547"></a>00547     }
<a name="l00548"></a>00548     <span class="keywordflow">if</span>(outer_rect.topLeft().y() &gt;= img_rect.topLeft().y()) {
<a name="l00549"></a>00549         where.setY(outer_rect.topLeft().y());
<a name="l00550"></a>00550         dirty.setY(1);
<a name="l00551"></a>00551     } <span class="keywordflow">else</span> {
<a name="l00552"></a>00552         where.setY(img_rect.topLeft().y());
<a name="l00553"></a>00553         dirty.setY(0);
<a name="l00554"></a>00554     }
<a name="l00555"></a>00555     <span class="comment">// Now the dirty trick for offset, using glBitmap:</span>
<a name="l00556"></a>00556     glRasterPos2f(zoom*(where.x()+dirty.x()+0.0001),zoom*(where.y()+dirty.y()+0.0001));
<a name="l00557"></a>00557     glBitmap(0, 0, 0, 0, -zoom*dirty.x(), +zoom*dirty.y(), NULL);
<a name="l00558"></a>00558 
<a name="l00559"></a>00559     <span class="comment">// ... and second, WHAT to draw:</span>
<a name="l00560"></a>00560     QRect what;
<a name="l00561"></a>00561     <span class="keywordtype">int</span> img_step = imagecopy-&gt;<a class="code" href="classQVGenericImage.html#a73b40cb2faa1943637116da270da800d" title="Virtual method for getting the row step of the image.">getStep</a>();
<a name="l00562"></a>00562     glPixelZoom(zoom,-zoom);
<a name="l00563"></a>00563     <span class="keywordflow">if</span>(outer_rect.topLeft().x() &gt;= img_rect.topLeft().x()) {
<a name="l00564"></a>00564         what.setX(outer_rect.topLeft().x() - img_rect.topLeft().x() + imagecopy-&gt;<a class="code" href="classQVGenericImage.html#a55132f8ba36904516dcf384039c670e4" title="Method for obtaining actual region of interest for image.">getROI</a>().topLeft().x());
<a name="l00565"></a>00565     } <span class="keywordflow">else</span> {
<a name="l00566"></a>00566         what.setX(imagecopy-&gt;<a class="code" href="classQVGenericImage.html#a55132f8ba36904516dcf384039c670e4" title="Method for obtaining actual region of interest for image.">getROI</a>().topLeft().x());
<a name="l00567"></a>00567     }
<a name="l00568"></a>00568     what.setWidth(final_rect.width());
<a name="l00569"></a>00569     <span class="keywordflow">if</span>(outer_rect.topLeft().y() &gt;= img_rect.topLeft().y()) {
<a name="l00570"></a>00570         what.setY(outer_rect.topLeft().y() - img_rect.topLeft().y() + imagecopy-&gt;<a class="code" href="classQVGenericImage.html#a55132f8ba36904516dcf384039c670e4" title="Method for obtaining actual region of interest for image.">getROI</a>().topLeft().y());
<a name="l00571"></a>00571     } <span class="keywordflow">else</span> {
<a name="l00572"></a>00572         what.setY(imagecopy-&gt;<a class="code" href="classQVGenericImage.html#a55132f8ba36904516dcf384039c670e4" title="Method for obtaining actual region of interest for image.">getROI</a>().topLeft().y());
<a name="l00573"></a>00573     }
<a name="l00574"></a>00574     what.setHeight(final_rect.height());
<a name="l00575"></a>00575 
<a name="l00576"></a>00576     <span class="keywordflow">if</span>(image-&gt;<a class="code" href="classQVGenericImage.html#a21b9bc211bcb5b0694ecdad16f1e5d59" title="Check whether an image is compatible in type with another image, provided its type...">isCompatibleWith</a>(<span class="stringliteral">&quot;QVImage&lt;uChar,1&gt;&quot;</span>)) {
<a name="l00577"></a>00577         glPixelStorei(GL_UNPACK_ROW_LENGTH,img_step);
<a name="l00578"></a>00578         glDrawPixels(what.width(),what.height(),
<a name="l00579"></a>00579                      GL_LUMINANCE,GL_UNSIGNED_BYTE,
<a name="l00580"></a>00580                      <span class="keyword">static_cast&lt;</span><a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;uchar,1&gt;</a> *<span class="keyword">&gt;</span>(imagecopy)-&gt;getReadData() +
<a name="l00581"></a>00581                      what.y()*img_step+what.x());
<a name="l00582"></a>00582     }
<a name="l00583"></a>00583     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(image-&gt;<a class="code" href="classQVGenericImage.html#a21b9bc211bcb5b0694ecdad16f1e5d59" title="Check whether an image is compatible in type with another image, provided its type...">isCompatibleWith</a>(<span class="stringliteral">&quot;QVImage&lt;uShort,1&gt;&quot;</span>)) {
<a name="l00584"></a>00584         glPixelStorei(GL_UNPACK_ROW_LENGTH,img_step/<span class="keyword">sizeof</span>(uShort));
<a name="l00585"></a>00585         glDrawPixels(what.width(),what.height(),
<a name="l00586"></a>00586                      GL_LUMINANCE,GL_UNSIGNED_SHORT,
<a name="l00587"></a>00587                      <span class="keyword">static_cast&lt;</span><a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;uShort,1&gt;</a> *<span class="keyword">&gt;</span>(imagecopy)-&gt;getReadData() +
<a name="l00588"></a>00588                      what.y()*img_step/<span class="keyword">sizeof</span>(uShort)+what.x());
<a name="l00589"></a>00589     }
<a name="l00590"></a>00590     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(image-&gt;<a class="code" href="classQVGenericImage.html#a21b9bc211bcb5b0694ecdad16f1e5d59" title="Check whether an image is compatible in type with another image, provided its type...">isCompatibleWith</a>(<span class="stringliteral">&quot;QVImage&lt;sShort,1&gt;&quot;</span>)) {
<a name="l00591"></a>00591         glPixelStorei(GL_UNPACK_ROW_LENGTH,img_step/<span class="keyword">sizeof</span>(sShort));
<a name="l00592"></a>00592 
<a name="l00593"></a>00593         <span class="keywordtype">float</span> scale=1.0/(high-low),bias=-low*scale;
<a name="l00594"></a>00594         glPixelTransferf(GL_RED_BIAS,bias);
<a name="l00595"></a>00595         glPixelTransferf(GL_GREEN_BIAS,bias);
<a name="l00596"></a>00596         glPixelTransferf(GL_BLUE_BIAS,bias);
<a name="l00597"></a>00597         glPixelTransferf(GL_RED_SCALE,scale);
<a name="l00598"></a>00598         glPixelTransferf(GL_GREEN_SCALE,scale);
<a name="l00599"></a>00599         glPixelTransferf(GL_BLUE_SCALE,scale);
<a name="l00600"></a>00600 
<a name="l00601"></a>00601         glDrawPixels(what.width(),what.height(),
<a name="l00602"></a>00602                      GL_LUMINANCE,GL_SHORT,
<a name="l00603"></a>00603                      <span class="keyword">static_cast&lt;</span><a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;sShort,1&gt;</a> *<span class="keyword">&gt;</span>(imagecopy)-&gt;getReadData() +
<a name="l00604"></a>00604                      what.y()*img_step/<span class="keyword">sizeof</span>(sShort)+what.x());
<a name="l00605"></a>00605     }
<a name="l00606"></a>00606     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(image-&gt;<a class="code" href="classQVGenericImage.html#a21b9bc211bcb5b0694ecdad16f1e5d59" title="Check whether an image is compatible in type with another image, provided its type...">isCompatibleWith</a>(<span class="stringliteral">&quot;QVImage&lt;sInt,1&gt;&quot;</span>)) {
<a name="l00607"></a>00607         glPixelStorei(GL_UNPACK_ROW_LENGTH,img_step/<span class="keyword">sizeof</span>(sInt));
<a name="l00608"></a>00608 
<a name="l00609"></a>00609         <span class="keywordtype">float</span> scale=1.0/(high-low),bias=-low*scale;
<a name="l00610"></a>00610         glPixelTransferf(GL_RED_BIAS,bias);
<a name="l00611"></a>00611         glPixelTransferf(GL_GREEN_BIAS,bias);
<a name="l00612"></a>00612         glPixelTransferf(GL_BLUE_BIAS,bias);
<a name="l00613"></a>00613         glPixelTransferf(GL_RED_SCALE,scale);
<a name="l00614"></a>00614         glPixelTransferf(GL_GREEN_SCALE,scale);
<a name="l00615"></a>00615         glPixelTransferf(GL_BLUE_SCALE,scale);
<a name="l00616"></a>00616 
<a name="l00617"></a>00617         glDrawPixels(what.width(),what.height(),
<a name="l00618"></a>00618                      GL_LUMINANCE,GL_INT,
<a name="l00619"></a>00619                      <span class="keyword">static_cast&lt;</span><a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;sInt,1&gt;</a> *<span class="keyword">&gt;</span>(imagecopy)-&gt;getReadData() +
<a name="l00620"></a>00620                      what.y()*img_step/<span class="keyword">sizeof</span>(sInt)+what.x());
<a name="l00621"></a>00621     }
<a name="l00622"></a>00622     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(image-&gt;<a class="code" href="classQVGenericImage.html#a21b9bc211bcb5b0694ecdad16f1e5d59" title="Check whether an image is compatible in type with another image, provided its type...">isCompatibleWith</a>(<span class="stringliteral">&quot;QVImage&lt;sFloat,1&gt;&quot;</span>)) {
<a name="l00623"></a>00623         glPixelStorei(GL_UNPACK_ROW_LENGTH,img_step/<span class="keyword">sizeof</span>(sFloat));
<a name="l00624"></a>00624 
<a name="l00625"></a>00625         <span class="keywordtype">float</span> scale=1.0/(high-low),bias=-low*scale;
<a name="l00626"></a>00626         <span class="comment">//float scale = 1.0/ (high-low),bias=0;</span>
<a name="l00627"></a>00627         glPixelTransferf(GL_RED_BIAS,bias);
<a name="l00628"></a>00628         glPixelTransferf(GL_GREEN_BIAS,bias);
<a name="l00629"></a>00629         glPixelTransferf(GL_BLUE_BIAS,bias);
<a name="l00630"></a>00630         glPixelTransferf(GL_RED_SCALE,scale);
<a name="l00631"></a>00631         glPixelTransferf(GL_GREEN_SCALE,scale);
<a name="l00632"></a>00632         glPixelTransferf(GL_BLUE_SCALE,scale);
<a name="l00633"></a>00633 
<a name="l00634"></a>00634 <span class="comment">/*              glPixelTransferf(GL_RED_SCALE,float(1.0)/(float)127.0);</span>
<a name="l00635"></a>00635 <span class="comment">        glPixelTransferf(GL_GREEN_SCALE,float(1.0)/(float)127.0);</span>
<a name="l00636"></a>00636 <span class="comment">        glPixelTransferf(GL_BLUE_SCALE,float(1.0)/(float)127.0);*/</span>
<a name="l00637"></a>00637         <span class="comment">// Take care with last parameter (pointer) in this call: it works</span>
<a name="l00638"></a>00638         <span class="comment">// because of the float* arithmetic:</span>
<a name="l00639"></a>00639         glDrawPixels(what.width(),what.height(),
<a name="l00640"></a>00640                      GL_LUMINANCE,GL_FLOAT,
<a name="l00641"></a>00641                      <span class="keyword">static_cast&lt;</span><a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;sFloat,1&gt;</a> *<span class="keyword">&gt;</span>(imagecopy)-&gt;getReadData() +
<a name="l00642"></a>00642                      what.y()*img_step/<span class="keyword">sizeof</span>(sFloat)+what.x());
<a name="l00643"></a>00643     }
<a name="l00644"></a>00644     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(image-&gt;<a class="code" href="classQVGenericImage.html#a21b9bc211bcb5b0694ecdad16f1e5d59" title="Check whether an image is compatible in type with another image, provided its type...">isCompatibleWith</a>(<span class="stringliteral">&quot;QVImage&lt;uChar,3&gt;&quot;</span>)) {
<a name="l00645"></a>00645         glPixelStorei(GL_UNPACK_ROW_LENGTH,img_step/3);
<a name="l00646"></a>00646         glDrawPixels(what.width(),what.height(),
<a name="l00647"></a>00647                     GL_RGB,GL_UNSIGNED_BYTE,
<a name="l00648"></a>00648                     <span class="keyword">static_cast&lt;</span><a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;uchar,3&gt;</a> *<span class="keyword">&gt;</span>(imagecopy)-&gt;getReadData() +
<a name="l00649"></a>00649                     what.y()*img_step+3*what.x());
<a name="l00650"></a>00650     }
<a name="l00651"></a>00651     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(image-&gt;<a class="code" href="classQVGenericImage.html#a21b9bc211bcb5b0694ecdad16f1e5d59" title="Check whether an image is compatible in type with another image, provided its type...">isCompatibleWith</a>(<span class="stringliteral">&quot;QVImage&lt;uShort,3&gt;&quot;</span>)) {
<a name="l00652"></a>00652         glPixelStorei(GL_UNPACK_ROW_LENGTH,img_step/(<span class="keyword">sizeof</span>(uShort)*3));
<a name="l00653"></a>00653         glDrawPixels(what.width(),what.height(),
<a name="l00654"></a>00654                     GL_RGB,GL_UNSIGNED_SHORT,
<a name="l00655"></a>00655                     <span class="keyword">static_cast&lt;</span><a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;uShort,3&gt;</a> *<span class="keyword">&gt;</span>(imagecopy)-&gt;getReadData() +
<a name="l00656"></a>00656                     what.y()*img_step/<span class="keyword">sizeof</span>(uShort)+3*what.x());
<a name="l00657"></a>00657     }
<a name="l00658"></a>00658     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(image-&gt;<a class="code" href="classQVGenericImage.html#a21b9bc211bcb5b0694ecdad16f1e5d59" title="Check whether an image is compatible in type with another image, provided its type...">isCompatibleWith</a>(<span class="stringliteral">&quot;QVImage&lt;sShort,3&gt;&quot;</span>)) {
<a name="l00659"></a>00659         glPixelStorei(GL_UNPACK_ROW_LENGTH,img_step/(<span class="keyword">sizeof</span>(sShort)*3));
<a name="l00660"></a>00660 
<a name="l00661"></a>00661         <span class="keywordtype">float</span> scale=1.0/(high-low),bias=-low*scale;
<a name="l00662"></a>00662         glPixelTransferf(GL_RED_BIAS,bias);
<a name="l00663"></a>00663         glPixelTransferf(GL_GREEN_BIAS,bias);
<a name="l00664"></a>00664         glPixelTransferf(GL_BLUE_BIAS,bias);
<a name="l00665"></a>00665         glPixelTransferf(GL_RED_SCALE,scale);
<a name="l00666"></a>00666         glPixelTransferf(GL_GREEN_SCALE,scale);
<a name="l00667"></a>00667         glPixelTransferf(GL_BLUE_SCALE,scale);
<a name="l00668"></a>00668 
<a name="l00669"></a>00669         glDrawPixels(what.width(),what.height(),
<a name="l00670"></a>00670                     GL_RGB,GL_SHORT,
<a name="l00671"></a>00671                     <span class="keyword">static_cast&lt;</span><a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;sShort,3&gt;</a> *<span class="keyword">&gt;</span>(imagecopy)-&gt;getReadData() +
<a name="l00672"></a>00672                     what.y()*img_step/<span class="keyword">sizeof</span>(sShort)+3*what.x());
<a name="l00673"></a>00673     }
<a name="l00674"></a>00674     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(image-&gt;<a class="code" href="classQVGenericImage.html#a21b9bc211bcb5b0694ecdad16f1e5d59" title="Check whether an image is compatible in type with another image, provided its type...">isCompatibleWith</a>(<span class="stringliteral">&quot;QVImage&lt;sInt,3&gt;&quot;</span>)) {
<a name="l00675"></a>00675         glPixelStorei(GL_UNPACK_ROW_LENGTH,img_step/(<span class="keyword">sizeof</span>(sInt)*3));
<a name="l00676"></a>00676 
<a name="l00677"></a>00677         <span class="keywordtype">float</span> scale=1.0/(high-low),bias=-low*scale;
<a name="l00678"></a>00678         glPixelTransferf(GL_RED_BIAS,bias);
<a name="l00679"></a>00679         glPixelTransferf(GL_GREEN_BIAS,bias);
<a name="l00680"></a>00680         glPixelTransferf(GL_BLUE_BIAS,bias);
<a name="l00681"></a>00681         glPixelTransferf(GL_RED_SCALE,scale);
<a name="l00682"></a>00682         glPixelTransferf(GL_GREEN_SCALE,scale);
<a name="l00683"></a>00683         glPixelTransferf(GL_BLUE_SCALE,scale);
<a name="l00684"></a>00684 
<a name="l00685"></a>00685         glDrawPixels(what.width(),what.height(),
<a name="l00686"></a>00686                      GL_RGB,GL_INT,
<a name="l00687"></a>00687                      <span class="keyword">static_cast&lt;</span><a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;sInt,3&gt;</a> *<span class="keyword">&gt;</span>(imagecopy)-&gt;getReadData() +
<a name="l00688"></a>00688                      what.y()*img_step/<span class="keyword">sizeof</span>(sInt)+3*what.x());
<a name="l00689"></a>00689     }
<a name="l00690"></a>00690     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(image-&gt;<a class="code" href="classQVGenericImage.html#a21b9bc211bcb5b0694ecdad16f1e5d59" title="Check whether an image is compatible in type with another image, provided its type...">isCompatibleWith</a>(<span class="stringliteral">&quot;QVImage&lt;sFloat,3&gt;&quot;</span>)) {
<a name="l00691"></a>00691         glPixelStorei(GL_UNPACK_ROW_LENGTH,img_step/(<span class="keyword">sizeof</span>(sFloat)*3));
<a name="l00692"></a>00692 
<a name="l00693"></a>00693         <span class="keywordtype">float</span> scale=1.0/(high-low),bias=-low*scale;
<a name="l00694"></a>00694         glPixelTransferf(GL_RED_BIAS,bias);
<a name="l00695"></a>00695         glPixelTransferf(GL_GREEN_BIAS,bias);
<a name="l00696"></a>00696         glPixelTransferf(GL_BLUE_BIAS,bias);
<a name="l00697"></a>00697         glPixelTransferf(GL_RED_SCALE,scale);
<a name="l00698"></a>00698         glPixelTransferf(GL_GREEN_SCALE,scale);
<a name="l00699"></a>00699         glPixelTransferf(GL_BLUE_SCALE,scale);
<a name="l00700"></a>00700 
<a name="l00701"></a>00701         glDrawPixels(what.width(),what.height(),
<a name="l00702"></a>00702                      GL_RGB,GL_FLOAT,
<a name="l00703"></a>00703                      <span class="keyword">static_cast&lt;</span><a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;sFloat,3&gt;</a> *<span class="keyword">&gt;</span>(imagecopy)-&gt;getReadData() +
<a name="l00704"></a>00704                      what.y()*img_step/<span class="keyword">sizeof</span>(sFloat)+3*what.x());
<a name="l00705"></a>00705     }
<a name="l00706"></a>00706     <span class="keywordflow">else</span> {
<a name="l00707"></a>00707         <span class="comment">// alternate code for that type of image ...</span>
<a name="l00708"></a>00708         qFatal(<span class="stringliteral">&quot;Type of QVGenericImage still not supported in drawQVImage&quot;</span>);
<a name="l00709"></a>00709     }
<a name="l00710"></a>00710 
<a name="l00711"></a>00711     <span class="comment">// Pop the OpenGL projection and modelview matrices off their respective</span>
<a name="l00712"></a>00712     <span class="comment">// stacks. Pop the OpenGL attributes off the attribute stack.</span>
<a name="l00713"></a>00713     glPopClientAttrib();
<a name="l00714"></a>00714     glPopAttrib();
<a name="l00715"></a>00715     glMatrixMode(GL_MODELVIEW);
<a name="l00716"></a>00716     glPopMatrix();
<a name="l00717"></a>00717     glMatrixMode(GL_PROJECTION);
<a name="l00718"></a>00718     glPopMatrix();
<a name="l00719"></a>00719 }
<a name="l00720"></a>00720 
<a name="l00721"></a>00721 
<a name="l00722"></a>00722 <span class="comment">// Camera coordinate system: X grows to the right, Y grows downwards, Z grows towards scene.</span>
<a name="l00723"></a>00723 <span class="comment">// This way, coordinate system is right handed (X x Y = Z), Z corresponds to depth, and</span>
<a name="l00724"></a>00724 <span class="comment">// pixel coordinates grow following the conventions of traditional windows systems.</span>
<a name="l00725"></a>00725 <span class="keywordtype">void</span> QVImageArea::beginDrawWorldFromCamera(<span class="keyword">const</span> <span class="keywordtype">double</span> fx, <span class="keyword">const</span> <span class="keywordtype">double</span> fy, <span class="keyword">const</span> <a class="code" href="classQVCameraPose.html" title="Class for the camera pose of a view, in a 3D reconstruction.">QVCameraPose</a> &amp;cameraPosition)
<a name="l00726"></a>00726 {
<a name="l00727"></a>00727     <span class="comment">// Prepare QT widget for native OpenGL calls:</span>
<a name="l00728"></a>00728 <span class="preprocessor">#ifdef QT_MIN_VERSION_4_6</span>
<a name="l00729"></a>00729 <span class="preprocessor"></span>    painter-&gt;beginNativePainting();
<a name="l00730"></a>00730 <span class="preprocessor">#else</span>
<a name="l00731"></a>00731 <span class="preprocessor"></span>    std::cerr &lt;&lt; <span class="stringliteral">&quot;[QVImageArea::beginDrawWorldFromCamera] Qt version &gt;= 4.6 is required for augmented reality functionality&quot;</span> &lt;&lt; std::endl;
<a name="l00732"></a>00732 <span class="preprocessor">#endif</span>
<a name="l00733"></a>00733 <span class="preprocessor"></span>
<a name="l00734"></a>00734     <span class="comment">// Save current projection and model matrices:</span>
<a name="l00735"></a>00735     glMatrixMode(GL_PROJECTION);
<a name="l00736"></a>00736     glPushMatrix();
<a name="l00737"></a>00737     glMatrixMode(GL_MODELVIEW);
<a name="l00738"></a>00738     glPushMatrix();
<a name="l00739"></a>00739 
<a name="l00740"></a>00740     <span class="comment">// Get current window zoom, top left position, width and height of viewport, field of view</span>
<a name="l00741"></a>00741     <span class="comment">// angle corresponding to focal, and convert all the values to float:</span>
<a name="l00742"></a>00742     <span class="comment">//float w_p = getSize().width(),h_p = getSize().height();</span>
<a name="l00743"></a>00743     <span class="comment">//float zoom = getZoom();</span>
<a name="l00744"></a>00744     <span class="keywordtype">float</span> w_p = origwidth,h_p = origheight, zm = zoom;
<a name="l00745"></a>00745     <span class="keywordtype">float</span> x = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(topLeft.x())/zm,y = static_cast&lt;float&gt;(topLeft.y())/zm;
<a name="l00746"></a>00746     <span class="keywordtype">float</span> w = width(), h = height();
<a name="l00747"></a>00747     <span class="keywordtype">float</span> fov = 2*atan2((<span class="keywordtype">float</span>)h_p/2,(<span class="keywordtype">float</span>)fy)*180/PI;
<a name="l00748"></a>00748     <span class="keywordtype">float</span> asp_rat = w_p/h_p;
<a name="l00749"></a>00749 
<a name="l00750"></a>00750     <span class="comment">// First, adjust projection matrix:</span>
<a name="l00751"></a>00751     glMatrixMode(GL_PROJECTION);
<a name="l00752"></a>00752     glLoadIdentity();
<a name="l00753"></a>00753     glTranslatef((w_p-w)/w,-(h_p-h)/h,0);
<a name="l00754"></a>00754     glScalef(zm,zm,1);
<a name="l00755"></a>00755     glScalef(w_p/w,h_p/h,1);
<a name="l00756"></a>00756     glTranslatef(-(x-(w_p/2-(w_p/2)/zm))/(w_p/2),(y-(h_p/2-(h_p/2)/zm))/(h_p/2),0);
<a name="l00757"></a>00757     qvGluPerspective(fov,asp_rat*fy/fx,0.1,15.0);
<a name="l00758"></a>00758 
<a name="l00759"></a>00759     <span class="comment">// Now, get R, C and T from camera position, and put R in axis/angle form:</span>
<a name="l00760"></a>00760     <a class="code" href="classQV3DPointF.html" title="3D point representation">QV3DPointF</a> C = cameraPosition.<a class="code" href="classQVCameraPose.html#a57101f0fd271736866f970c1635dd7c1" title="Center of the camera pose.">getCenter</a>();
<a name="l00761"></a>00761     <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> R = cameraPosition.<a class="code" href="classQVCameraPose.html#a8643ae492e7a6f66679bf0cc2fc911c7" title="Orientation of the camera pose.">getOrientation</a>().<a class="code" href="classQVQuaternion.html#a00c343b8018cfc98536b13ff31341751" title="Gets the rotation matrix corresponding to the Quaternion.">toRotationMatrix</a>();
<a name="l00762"></a>00762     <a class="code" href="classQV3DPointF.html" title="3D point representation">QV3DPointF</a> T = -R * C;
<a name="l00763"></a>00763     <a class="code" href="classQV3DPointF.html" title="3D point representation">QV3DPointF</a> rotVect = <a class="code" href="group__qvmath.html#ga85e11a75a24eec1686a939aa690e1942" title="Obtains the element from the Lie algebra so(3) corresponding to a rotation matrix...">lnSO3</a>(R);
<a name="l00764"></a>00764     <span class="keywordtype">float</span> angle = rotVect.<a class="code" href="classQVVector.html#a49c6f41f1fa80efcc943f1c26fdcbf05" title="Norm 2 of the vector.">norm2</a>();
<a name="l00765"></a>00765     <a class="code" href="classQV3DPointF.html" title="3D point representation">QV3DPointF</a> axis = rotVect/angle;
<a name="l00766"></a>00766 
<a name="l00767"></a>00767     <span class="comment">//Finally, adjust model matrix accordingly:</span>
<a name="l00768"></a>00768     glMatrixMode(GL_MODELVIEW);
<a name="l00769"></a>00769     glLoadIdentity();
<a name="l00770"></a>00770     glTranslatef(T.<a class="code" href="classQV3DPointF.html#aab1c8e4380b126607771339778a83a1e" title="Gets the value for the first coordinate of the 3D point.">x</a>(),-T.<a class="code" href="classQV3DPointF.html#ab3999406794a8d4afa0718af691b8920" title="Gets the value for the second coordinate of the 3D point.">y</a>(),-T.<a class="code" href="classQV3DPointF.html#aba286a7e040358ecbffce7c4566cdd8d" title="Gets the value for the third coordinate of the 3D point.">z</a>());
<a name="l00771"></a>00771     glRotatef(angle*180/PI,axis.<a class="code" href="classQV3DPointF.html#aab1c8e4380b126607771339778a83a1e" title="Gets the value for the first coordinate of the 3D point.">x</a>(),-axis.<a class="code" href="classQV3DPointF.html#ab3999406794a8d4afa0718af691b8920" title="Gets the value for the second coordinate of the 3D point.">y</a>(),-axis.<a class="code" href="classQV3DPointF.html#aba286a7e040358ecbffce7c4566cdd8d" title="Gets the value for the third coordinate of the 3D point.">z</a>());
<a name="l00772"></a>00772     glScalef(1,-1,-1);
<a name="l00773"></a>00773 }
<a name="l00774"></a>00774 
<a name="l00775"></a>00775 
<a name="l00776"></a>00776 <span class="keywordtype">void</span> QVImageArea::endDrawWorldFromCamera(<span class="keywordtype">void</span>)
<a name="l00777"></a>00777 {
<a name="l00778"></a>00778     <span class="comment">// Recover old projection and model matrices:</span>
<a name="l00779"></a>00779     glMatrixMode(GL_PROJECTION);
<a name="l00780"></a>00780     glPopMatrix();
<a name="l00781"></a>00781     glMatrixMode(GL_MODELVIEW);
<a name="l00782"></a>00782     glPopMatrix();
<a name="l00783"></a>00783 
<a name="l00784"></a>00784     <span class="comment">// And notice QT widget that native OpenGL calls have finished:</span>
<a name="l00785"></a>00785 <span class="preprocessor">#ifdef QT_MIN_VERSION_4_6</span>
<a name="l00786"></a>00786 <span class="preprocessor"></span>    painter-&gt;endNativePainting();
<a name="l00787"></a>00787 <span class="preprocessor">#else</span>
<a name="l00788"></a>00788 <span class="preprocessor"></span>    std::cerr &lt;&lt; <span class="stringliteral">&quot;[QVImageArea::endDrawWorldFromCamera] Qt version &gt;= 4.6 is required for augmented reality functionality&quot;</span> &lt;&lt; std::endl;
<a name="l00789"></a>00789 <span class="preprocessor">#endif</span>
<a name="l00790"></a>00790 <span class="preprocessor"></span>}
<a name="l00791"></a>00791 
<a name="l00792"></a>00792 <span class="keywordtype">void</span> QVImageArea::mousePressEvent(QMouseEvent *event)
<a name="l00793"></a>00793 {
<a name="l00794"></a>00794     firstPos = <span class="keyword">event</span>-&gt;pos();
<a name="l00795"></a>00795     dragging = TRUE;
<a name="l00796"></a>00796     <span class="keywordflow">if</span>(mouseMode == DRAG) {
<a name="l00797"></a>00797         setCursor(Qt::ClosedHandCursor);
<a name="l00798"></a>00798     }
<a name="l00799"></a>00799 
<a name="l00800"></a>00800     <span class="keywordflow">if</span> ( (mouseMode == <span class="keywordtype">SEL</span>) &amp;&amp; (event-&gt;button() == Qt::RightButton) ) {
<a name="l00801"></a>00801         selRect = QRect();
<a name="l00802"></a>00802         emit rectSelected(QRect());
<a name="l00803"></a>00803     }
<a name="l00804"></a>00804 
<a name="l00805"></a>00805     <span class="comment">// add a new point to the polyline</span>
<a name="l00806"></a>00806     <span class="keywordflow">if</span> (mouseMode == POLY) {
<a name="l00807"></a>00807         <span class="keywordflow">if</span> (event-&gt;button() == Qt::RightButton) {
<a name="l00808"></a>00808             selPoly = <a class="code" href="classQVPolyline.html" title="Polyline representation.">QVPolyline</a>();
<a name="l00809"></a>00809             emit polySelected(QPoint(), <span class="keyword">true</span>, polyMode);
<a name="l00810"></a>00810         } <span class="keywordflow">else</span> {
<a name="l00811"></a>00811             QPoint pos = <span class="keyword">event</span>-&gt;pos();
<a name="l00812"></a>00812             QPoint point(qRound(-0.5+static_cast&lt;float&gt;(pos.x()+topLeft.x())/zoom), qRound(-0.5+static_cast&lt;float&gt;(pos.y()+topLeft.y())/zoom));
<a name="l00813"></a>00813             selPoly.append(point);
<a name="l00814"></a>00814             emit polySelected(point, <span class="keyword">false</span>, polyMode);
<a name="l00815"></a>00815         }
<a name="l00816"></a>00816     }
<a name="l00817"></a>00817     makeCurrent();
<a name="l00818"></a>00818     update();
<a name="l00819"></a>00819 }
<a name="l00820"></a>00820 
<a name="l00821"></a>00821 <span class="keywordtype">void</span> QVImageArea::mouseMoveEvent(QMouseEvent *event)
<a name="l00822"></a>00822 {
<a name="l00823"></a>00823     <span class="keywordflow">if</span>(dragging) {
<a name="l00824"></a>00824         lastPos = <span class="keyword">event</span>-&gt;pos();
<a name="l00825"></a>00825         <span class="keywordflow">switch</span>(mouseMode) {
<a name="l00826"></a>00826         <span class="keywordflow">case</span> DRAG: {
<a name="l00827"></a>00827             QPoint minDesp = -topLeft,
<a name="l00828"></a>00828                 maxDesp = QPoint(origwidth*zoom,origheight*zoom) -
<a name="l00829"></a>00829                             (topLeft + QPoint(width(),height()));
<a name="l00830"></a>00830             QPoint desp = firstPos-lastPos,
<a name="l00831"></a>00831                 boundDesp = QPoint(qBound(minDesp.x(),desp.x(),maxDesp.x()),
<a name="l00832"></a>00832                                     qBound(minDesp.y(),desp.y(),maxDesp.y()));
<a name="l00833"></a>00833             <span class="keywordflow">if</span>(boundDesp != QPoint(0,0)) {
<a name="l00834"></a>00834                 topLeft = topLeft+boundDesp;
<a name="l00835"></a>00835                 makeCurrent();
<a name="l00836"></a>00836                 update();
<a name="l00837"></a>00837                 emit newGeometry(origwidth,origheight,topLeft.x(),topLeft.y(),width(),height(),zoom);
<a name="l00838"></a>00838             }
<a name="l00839"></a>00839             firstPos = lastPos;
<a name="l00840"></a>00840             emit mouseLeavesImageArea(FALSE);
<a name="l00841"></a>00841             emit newMousePosition(static_cast&lt;float&gt;(event-&gt;x()+topLeft.x())/zoom,static_cast&lt;float&gt;(event-&gt;y()+topLeft.y())/zoom);
<a name="l00842"></a>00842             <span class="keywordflow">break</span>;
<a name="l00843"></a>00843             }
<a name="l00844"></a>00844         <span class="keywordflow">case</span> ZOOM: {
<a name="l00845"></a>00845             QPoint p1(qRound(static_cast&lt;float&gt;(firstPos.x()+topLeft.x())/zoom),
<a name="l00846"></a>00846                     qRound(static_cast&lt;float&gt;(firstPos.y()+topLeft.y())/zoom)),
<a name="l00847"></a>00847                 p2(qRound(static_cast&lt;float&gt;(lastPos.x()+topLeft.x())/zoom)-1,
<a name="l00848"></a>00848                     qRound(static_cast&lt;float&gt;(lastPos.y()+topLeft.y())/zoom)-1);
<a name="l00849"></a>00849 
<a name="l00850"></a>00850             <span class="comment">// Warning: QT (lesser) error when constructing rectangles of type QRect(QPoint(x,y),QPoint(x-1,y&#39;)),</span>
<a name="l00851"></a>00851             <span class="comment">// as well QRect(QPoint(x,y),QPoint(x&#39;,y-1)). In practice, it is not important, so we won&#39;t</span>
<a name="l00852"></a>00852             <span class="comment">// blur the code.</span>
<a name="l00853"></a>00853             zoomRect = QRect(p1,p2) &amp; innerRect(); <span class="comment">// Intersection</span>
<a name="l00854"></a>00854             emit mouseLeavesImageArea(FALSE);
<a name="l00855"></a>00855             emit newMousePosition(lastPos.x()&gt;firstPos.x()?zoomRect.right():zoomRect.left(), lastPos.y()&gt;firstPos.y()?zoomRect.bottom():zoomRect.top());
<a name="l00856"></a>00856             makeCurrent();
<a name="l00857"></a>00857             update();
<a name="l00858"></a>00858             <span class="keywordflow">break</span>;
<a name="l00859"></a>00859             }
<a name="l00860"></a>00860         <span class="keywordflow">case</span> <span class="keywordtype">SEL</span>: {
<a name="l00861"></a>00861             QPoint p1(qRound(static_cast&lt;float&gt;(firstPos.x()+topLeft.x())/zoom),
<a name="l00862"></a>00862                     qRound(static_cast&lt;float&gt;(firstPos.y()+topLeft.y())/zoom)),
<a name="l00863"></a>00863                 p2(qRound(static_cast&lt;float&gt;(lastPos.x()+topLeft.x())/zoom)-1,
<a name="l00864"></a>00864                     qRound(static_cast&lt;float&gt;(lastPos.y()+topLeft.y())/zoom)-1);
<a name="l00865"></a>00865 
<a name="l00866"></a>00866             selRect = QRect(p1,p2) &amp; innerRect(); <span class="comment">// Intersection</span>
<a name="l00867"></a>00867             emit rectSelected(selRect);
<a name="l00868"></a>00868             emit mouseLeavesImageArea(FALSE);
<a name="l00869"></a>00869             emit newMousePosition(lastPos.x()&gt;firstPos.x()?selRect.right():selRect.left(), lastPos.y()&gt;firstPos.y()?selRect.bottom():selRect.top());
<a name="l00870"></a>00870             makeCurrent();
<a name="l00871"></a>00871             update();
<a name="l00872"></a>00872             <span class="keywordflow">break</span>;
<a name="l00873"></a>00873             }
<a name="l00874"></a>00874         <span class="keywordflow">case</span> POLY: {
<a name="l00875"></a>00875             <span class="keywordflow">break</span>;
<a name="l00876"></a>00876             }
<a name="l00877"></a>00877         <span class="keywordflow">case</span> NONE: {
<a name="l00878"></a>00878             <span class="keywordflow">break</span>;
<a name="l00879"></a>00879             }
<a name="l00880"></a>00880         }
<a name="l00881"></a>00881     } <span class="keywordflow">else</span> {
<a name="l00882"></a>00882         emit mouseLeavesImageArea(FALSE);
<a name="l00883"></a>00883         emit newMousePosition(static_cast&lt;float&gt;(event-&gt;x()+topLeft.x())/zoom,static_cast&lt;float&gt;(event-&gt;y()+topLeft.y())/zoom);
<a name="l00884"></a>00884     }
<a name="l00885"></a>00885 }
<a name="l00886"></a>00886 
<a name="l00887"></a>00887 
<a name="l00888"></a>00888 <span class="keywordtype">void</span> QVImageArea::mouseReleaseEvent(QMouseEvent *event)
<a name="l00889"></a>00889 {
<a name="l00890"></a>00890     <span class="comment">//Q_UNUSED(event);</span>
<a name="l00891"></a>00891     <span class="keywordflow">if</span>(mouseMode == DRAG) {
<a name="l00892"></a>00892         setCursor(Qt::OpenHandCursor);
<a name="l00893"></a>00893     }
<a name="l00894"></a>00894     dragging = FALSE;
<a name="l00895"></a>00895     lastPos = <span class="keyword">event</span>-&gt;pos();
<a name="l00896"></a>00896     <span class="keywordflow">switch</span>(mouseMode) {
<a name="l00897"></a>00897       <span class="keywordflow">case</span> DRAG: {
<a name="l00898"></a>00898         <span class="keywordflow">break</span>;
<a name="l00899"></a>00899       }
<a name="l00900"></a>00900       <span class="keywordflow">case</span> ZOOM: {
<a name="l00901"></a>00901         <span class="keywordtype">int</span> newzoom = zoom;
<a name="l00902"></a>00902 
<a name="l00903"></a>00903         <span class="keywordflow">if</span> (zoomRect.width() &lt; 1 or zoomRect.height() &lt; 1) <span class="comment">// if the rect is too small, the newzoom must be too great</span>
<a name="l00904"></a>00904             newzoom = max_zoom + 1;
<a name="l00905"></a>00905         <span class="keywordflow">else</span> {
<a name="l00906"></a>00906             <span class="keywordflow">do</span> {
<a name="l00907"></a>00907                 <span class="keywordflow">if</span> (newzoom &lt; 2) newzoom++; <span class="comment">// in order to grown always</span>
<a name="l00908"></a>00908                 <span class="keywordflow">else</span> newzoom = 2*newzoom;
<a name="l00909"></a>00909             }
<a name="l00910"></a>00910             <span class="keywordflow">while</span>(newzoom*zoomRect.width() &lt; minimumWidth() or newzoom*zoomRect.height() &lt; minimumHeight());
<a name="l00911"></a>00911         }
<a name="l00912"></a>00912 
<a name="l00913"></a>00913         if(newzoom &lt;= max_zoom) {
<a name="l00914"></a>00914             zoom = newzoom;
<a name="l00915"></a>00915             topLeft = zoom*zoomRect.topLeft();
<a name="l00916"></a>00916             setMaximumSize(zoom*origwidth,zoom*origheight);
<a name="l00917"></a>00917             resize(zoom*zoomRect.width(),zoom*zoomRect.height());
<a name="l00918"></a>00918             zoomRect = QRect();
<a name="l00919"></a>00919             makeCurrent();
<a name="l00920"></a>00920             update();
<a name="l00921"></a>00921             emit newGeometry(origwidth,origheight,topLeft.x(),topLeft.y(),width(),height(),zoom);
<a name="l00922"></a>00922         } <span class="keywordflow">else</span> {
<a name="l00923"></a>00923             zoomRect = QRect();
<a name="l00924"></a>00924             makeCurrent();
<a name="l00925"></a>00925             update();
<a name="l00926"></a>00926         }
<a name="l00927"></a>00927         <span class="keywordflow">break</span>;
<a name="l00928"></a>00928       }
<a name="l00929"></a>00929       <span class="keywordflow">case</span> <span class="keywordtype">SEL</span>: {
<a name="l00930"></a>00930         <span class="keywordflow">if</span>(event-&gt;button() == Qt::RightButton) {
<a name="l00931"></a>00931             selRect = QRect();
<a name="l00932"></a>00932             emit rectSelected(QRect());
<a name="l00933"></a>00933             makeCurrent();
<a name="l00934"></a>00934             update();
<a name="l00935"></a>00935         }
<a name="l00936"></a>00936         <span class="keywordflow">break</span>;
<a name="l00937"></a>00937       }
<a name="l00938"></a>00938       <span class="keywordflow">case</span> POLY: {
<a name="l00939"></a>00939         <span class="keywordflow">break</span>;
<a name="l00940"></a>00940       }
<a name="l00941"></a>00941       <span class="keywordflow">case</span> NONE: {
<a name="l00942"></a>00942         <span class="keywordflow">break</span>;
<a name="l00943"></a>00943       }
<a name="l00944"></a>00944     }
<a name="l00945"></a>00945 }
<a name="l00946"></a>00946 
<a name="l00947"></a>00947 <span class="keywordtype">void</span> QVImageArea::leaveEvent(QEvent *event)
<a name="l00948"></a>00948 {
<a name="l00949"></a>00949     Q_UNUSED(event);
<a name="l00950"></a>00950     emit mouseLeavesImageArea(TRUE);
<a name="l00951"></a>00951 }
<a name="l00952"></a>00952 
<a name="l00953"></a>00953 
<a name="l00954"></a>00954 <span class="comment">/******************************************************************************/</span>
<a name="l00955"></a>00955 
<a name="l00956"></a>00956 <span class="keywordtype">void</span> QVCanvas::resizeEvent(QResizeEvent *event)
<a name="l00957"></a>00957 {
<a name="l00958"></a>00958     QFontMetrics fm(font());
<a name="l00959"></a>00959 
<a name="l00960"></a>00960     <span class="keywordtype">int</span> w = <span class="keyword">event</span>-&gt;size().width() - scaleWidgetsFixedWidth - 1;
<a name="l00961"></a>00961     <span class="keywordtype">int</span> h = <span class="keyword">event</span>-&gt;size().height() - scaleWidgetsFixedWidth - statusBarWidgetFixedHeight - 1;
<a name="l00962"></a>00962     imageArea-&gt;setGeometry(scaleWidgetsFixedWidth,scaleWidgetsFixedWidth,w,h);
<a name="l00963"></a>00963 }
<a name="l00964"></a>00964 
<a name="l00965"></a>00965 QString QVCanvas::statusMessage()
<a name="l00966"></a>00966 {
<a name="l00967"></a>00967     <span class="keywordflow">if</span>(mouseIsOut) {
<a name="l00968"></a>00968         <span class="keywordflow">return</span> QString(<span class="stringliteral">&quot;z=%1&quot;</span>).arg(imageArea-&gt;zoom);
<a name="l00969"></a>00969     } <span class="keywordflow">else</span> {
<a name="l00970"></a>00970         <span class="keywordflow">return</span> QString(<span class="stringliteral">&quot;(%1,%2) z=%3&quot;</span>).arg(mousePosX).arg(mousePosY).arg(imageArea-&gt;zoom);
<a name="l00971"></a>00971     }
<a name="l00972"></a>00972 }
<a name="l00973"></a>00973 
<a name="l00974"></a>00974 QVCanvas::QVCanvas(QWidget *parent) : QWidget(parent)
<a name="l00975"></a>00975 {
<a name="l00976"></a>00976     mouseIsOut = TRUE;
<a name="l00977"></a>00977     <span class="keywordtype">int</span> w = 1, h = 1;
<a name="l00978"></a>00978     <span class="comment">// Scale widgets fixed width proportional to font height:</span>
<a name="l00979"></a>00979     QFontMetrics fm(font());
<a name="l00980"></a>00980     scaleWidgetsFixedWidth = 5*fm.height()/3;
<a name="l00981"></a>00981 
<a name="l00982"></a>00982 <span class="preprocessor">    #ifdef QVQWT</span>
<a name="l00983"></a>00983 <span class="preprocessor"></span>    <span class="comment">// Scale widgets creation:</span>
<a name="l00984"></a>00984     scaleWidgetX = <span class="keyword">new</span> QwtScaleWidget(QwtScaleDraw::TopScale,<span class="keyword">this</span>);
<a name="l00985"></a>00985     <span class="comment">//scaleWidgetX-&gt;setLabelRotation(0.0);</span>
<a name="l00986"></a>00986     scaleWidgetX-&gt;setLabelAlignment(Qt::AlignHCenter|Qt::AlignTop);
<a name="l00987"></a>00987     scaleWidgetX-&gt;setMargin(1);
<a name="l00988"></a>00988     <span class="comment">// Left and right (top &amp; bottom) scaleWidgetsFixedWidth for scale widgets</span>
<a name="l00989"></a>00989     <span class="comment">// (Otherwise, setBorderDist does not work!);</span>
<a name="l00990"></a>00990     <span class="comment">//scaleWidgetX-&gt;setBorderDist(scaleWidgetsFixedWidth,0);</span>
<a name="l00991"></a>00991     scaleWidgetX-&gt;setBorderDist(scaleWidgetsFixedWidth,scaleWidgetsFixedWidth);
<a name="l00992"></a>00992 
<a name="l00993"></a>00993     scaleWidgetY = <span class="keyword">new</span> QwtScaleWidget(QwtScaleDraw::LeftScale,<span class="keyword">this</span>);
<a name="l00994"></a>00994     scaleWidgetY-&gt;setLabelRotation(-90.0);
<a name="l00995"></a>00995     scaleWidgetY-&gt;setLabelAlignment(Qt::AlignVCenter|Qt::AlignTop);
<a name="l00996"></a>00996     scaleWidgetY-&gt;setMargin(1);
<a name="l00997"></a>00997     <span class="comment">// Left and right (top &amp; bottom) scaleWidgetsFixedWidth for scale widgets</span>
<a name="l00998"></a>00998     <span class="comment">// (Otherwise, setBorderDist does not work!);</span>
<a name="l00999"></a>00999     <span class="comment">//scaleWidgetY-&gt;setBorderDist(scaleWidgetsFixedWidth,0);</span>
<a name="l01000"></a>01000     scaleWidgetY-&gt;setBorderDist(scaleWidgetsFixedWidth,scaleWidgetsFixedWidth);
<a name="l01001"></a>01001 
<a name="l01002"></a>01002     <span class="comment">// Scale engines creation:</span>
<a name="l01003"></a>01003     scaleEngineX = <span class="keyword">new</span> QwtLinearScaleEngine;
<a name="l01004"></a>01004     scaleEngineY = <span class="keyword">new</span> QwtLinearScaleEngine;
<a name="l01005"></a>01005 <span class="preprocessor">    #endif</span>
<a name="l01006"></a>01006 <span class="preprocessor"></span>
<a name="l01007"></a>01007     <span class="comment">// QVImageArea creation: if there are others image areas, the new image area will share its contex with the first, in order not to slow down the application</span>
<a name="l01008"></a>01008     <span class="keywordflow">if</span>(image_areas.isEmpty()) {
<a name="l01009"></a>01009         <span class="comment">// If first instance, create widget with brand new context:</span>
<a name="l01010"></a>01010         imageArea = <span class="keyword">new</span> QVImageArea(w,h,<span class="keyword">this</span>);
<a name="l01011"></a>01011     }
<a name="l01012"></a>01012     <span class="keywordflow">else</span> {
<a name="l01013"></a>01013         <span class="comment">// For the rest of instances, create with the initial context: first (not deleted) imageArea&#39;s context</span>
<a name="l01014"></a>01014         imageArea = <span class="keyword">new</span> QVImageArea(w,h,<span class="keyword">this</span>,image_areas.first());
<a name="l01015"></a>01015     }
<a name="l01016"></a>01016     <span class="comment">// appends its reference, in the image_areas list (in case it becomes the first image area, the new imageAreas can shared its context)</span>
<a name="l01017"></a>01017     image_areas.append(imageArea);
<a name="l01018"></a>01018 
<a name="l01019"></a>01019     statusBar = <span class="keyword">new</span> QStatusBar(<span class="keyword">this</span>);
<a name="l01020"></a>01020     statusBar-&gt;addPermanentWidget(buttonDrawSel = <span class="keyword">new</span> QToolButton(statusBar));
<a name="l01021"></a>01021     statusBar-&gt;addPermanentWidget(buttonZoomIn = <span class="keyword">new</span> QToolButton(statusBar));
<a name="l01022"></a>01022     statusBar-&gt;addPermanentWidget(buttonZoomOut = <span class="keyword">new</span> QToolButton(statusBar));
<a name="l01023"></a>01023     statusBar-&gt;addPermanentWidget(buttonZoomOriginal = <span class="keyword">new</span> QToolButton(statusBar));
<a name="l01024"></a>01024     statusBar-&gt;addPermanentWidget(buttonZoomRect = <span class="keyword">new</span> QToolButton(statusBar));
<a name="l01025"></a>01025     statusBar-&gt;addPermanentWidget(buttonselPoly = <span class="keyword">new</span> QToolButton(statusBar));
<a name="l01026"></a>01026     statusBar-&gt;addPermanentWidget(buttonSelRect = <span class="keyword">new</span> QToolButton(statusBar));
<a name="l01027"></a>01027     statusBar-&gt;addPermanentWidget(buttonDrag = <span class="keyword">new</span> QToolButton(statusBar));
<a name="l01028"></a>01028     buttonDrawSel-&gt;setCheckable(TRUE);
<a name="l01029"></a>01029     buttonDrawSel-&gt;setIcon(QIcon(<span class="stringliteral">&quot;:/images/drawsel.png&quot;</span>));
<a name="l01030"></a>01030     buttonDrawSel-&gt;setChecked(TRUE);
<a name="l01031"></a>01031     buttonZoomIn-&gt;setCheckable(FALSE);
<a name="l01032"></a>01032     buttonZoomIn-&gt;setIcon(QIcon(<span class="stringliteral">&quot;:/images/zoom-in.png&quot;</span>));
<a name="l01033"></a>01033     buttonZoomOut-&gt;setCheckable(FALSE);
<a name="l01034"></a>01034     buttonZoomOut-&gt;setIcon(QIcon(<span class="stringliteral">&quot;:/images/zoom-out.png&quot;</span>));
<a name="l01035"></a>01035     buttonZoomOriginal-&gt;setCheckable(FALSE);
<a name="l01036"></a>01036     buttonZoomOriginal-&gt;setIcon(QIcon(<span class="stringliteral">&quot;:/images/zoom-original.png&quot;</span>));
<a name="l01037"></a>01037     buttonZoomRect-&gt;setCheckable(TRUE);
<a name="l01038"></a>01038     buttonZoomRect-&gt;setIcon(QIcon(<span class="stringliteral">&quot;:/images/zoom-best-fit.png&quot;</span>));
<a name="l01039"></a>01039     buttonselPoly-&gt;setCheckable(TRUE);
<a name="l01040"></a>01040     buttonselPoly-&gt;setIcon(QIcon(<span class="stringliteral">&quot;:/images/list.png&quot;</span>));
<a name="l01041"></a>01041     menuselPoly = <span class="keyword">new</span> QMenu();
<a name="l01042"></a>01042     menuselPoly-&gt;addAction(QIcon(<span class="stringliteral">&quot;:/images/list.png&quot;</span>), <span class="stringliteral">&quot;points&quot;</span>, <span class="keyword">this</span>, SLOT(selPolyChangedToList()));
<a name="l01043"></a>01043     menuselPoly-&gt;addAction(QIcon(<span class="stringliteral">&quot;:/images/poly.png&quot;</span>), <span class="stringliteral">&quot;polyline&quot;</span>, <span class="keyword">this</span>, SLOT(selPolyChangedToLine()));
<a name="l01044"></a>01044     menuselPoly-&gt;addAction(QIcon(<span class="stringliteral">&quot;:/images/polyclosed.png&quot;</span>), <span class="stringliteral">&quot;closed polyline&quot;</span>, <span class="keyword">this</span>, SLOT(selPolyChangedToClosed()));
<a name="l01045"></a>01045     buttonselPoly-&gt;setMenu(menuselPoly);
<a name="l01046"></a>01046     polyMode = LIST;
<a name="l01047"></a>01047     buttonSelRect-&gt;setCheckable(TRUE);
<a name="l01048"></a>01048     buttonSelRect-&gt;setIcon(QIcon(<span class="stringliteral">&quot;:/images/select.png&quot;</span>));
<a name="l01049"></a>01049     buttonDrag-&gt;setCheckable(TRUE);
<a name="l01050"></a>01050     buttonDrag-&gt;setIcon(QIcon(<span class="stringliteral">&quot;:/images/hand.png&quot;</span>));
<a name="l01051"></a>01051 
<a name="l01052"></a>01052     statusBar-&gt;showMessage(statusMessage());
<a name="l01053"></a>01053     statusBarWidgetFixedHeight = statusBar-&gt;height();
<a name="l01054"></a>01054 
<a name="l01055"></a>01055     setMinimumSize(scaleWidgetsFixedWidth + imageArea-&gt;minimumWidth() + 1,
<a name="l01056"></a>01056                    scaleWidgetsFixedWidth + imageArea-&gt;minimumHeight() + 1 +
<a name="l01057"></a>01057                    statusBarWidgetFixedHeight);
<a name="l01058"></a>01058     setMaximumSize(scaleWidgetsFixedWidth + w + 1,
<a name="l01059"></a>01059                    scaleWidgetsFixedWidth + h + 1 +
<a name="l01060"></a>01060                    statusBarWidgetFixedHeight);
<a name="l01061"></a>01061     resize(scaleWidgetsFixedWidth + w + 1,
<a name="l01062"></a>01062            scaleWidgetsFixedWidth + h + 1 +
<a name="l01063"></a>01063            statusBarWidgetFixedHeight);
<a name="l01064"></a>01064     connect(imageArea,SIGNAL(newGeometry(<span class="keywordtype">int</span>,<span class="keywordtype">int</span>,<span class="keywordtype">int</span>,<span class="keywordtype">int</span>,<span class="keywordtype">int</span>,<span class="keywordtype">int</span>,<span class="keywordtype">int</span>)),
<a name="l01065"></a>01065             <span class="keyword">this</span>,SLOT(setGeometry(<span class="keywordtype">int</span>,<span class="keywordtype">int</span>,<span class="keywordtype">int</span>,<span class="keywordtype">int</span>,<span class="keywordtype">int</span>,<span class="keywordtype">int</span>,<span class="keywordtype">int</span>)));
<a name="l01066"></a>01066     connect(imageArea,SIGNAL(newMousePosition(<span class="keywordtype">float</span>,<span class="keywordtype">float</span>)),
<a name="l01067"></a>01067             <span class="keyword">this</span>,SLOT(newMousePositionSlot(<span class="keywordtype">float</span>,<span class="keywordtype">float</span>)));
<a name="l01068"></a>01068     connect(imageArea,SIGNAL(mouseLeavesImageArea(<span class="keywordtype">bool</span>)),
<a name="l01069"></a>01069             <span class="keyword">this</span>,SLOT(mouseLeavesImageAreaSlot(<span class="keywordtype">bool</span>)));
<a name="l01070"></a>01070     connect(imageArea, SIGNAL(rectSelected(QRect)),
<a name="l01071"></a>01071             <span class="keyword">this</span>, SLOT(rectSelectedSlot(QRect)));
<a name="l01072"></a>01072     connect(imageArea, SIGNAL(polySelected(QPoint,<span class="keywordtype">bool</span>,TPolyMode)),
<a name="l01073"></a>01073             <span class="keyword">this</span>, SLOT(polySelectedSlot(QPoint,<span class="keywordtype">bool</span>,TPolyMode)));
<a name="l01074"></a>01074     connect(buttonDrawSel,SIGNAL(clicked(<span class="keywordtype">bool</span>)),<span class="keyword">this</span>,SLOT(drawSelClicked(<span class="keywordtype">bool</span>)));
<a name="l01075"></a>01075     connect(buttonZoomRect,SIGNAL(clicked(<span class="keywordtype">bool</span>)),<span class="keyword">this</span>,SLOT(zoomRectClicked(<span class="keywordtype">bool</span>)));
<a name="l01076"></a>01076     connect(buttonselPoly,SIGNAL(clicked(<span class="keywordtype">bool</span>)),<span class="keyword">this</span>,SLOT(selPolyClicked(<span class="keywordtype">bool</span>)));
<a name="l01077"></a>01077     connect(buttonSelRect,SIGNAL(clicked(<span class="keywordtype">bool</span>)),<span class="keyword">this</span>,SLOT(selRectClicked(<span class="keywordtype">bool</span>)));
<a name="l01078"></a>01078     connect(buttonDrag,SIGNAL(clicked(<span class="keywordtype">bool</span>)),<span class="keyword">this</span>,SLOT(dragClicked(<span class="keywordtype">bool</span>)));
<a name="l01079"></a>01079     connect(buttonZoomIn,SIGNAL(clicked()),<span class="keyword">this</span>,SLOT(zoomInClicked()));
<a name="l01080"></a>01080     connect(buttonZoomOut,SIGNAL(clicked()),<span class="keyword">this</span>,SLOT(zoomOutClicked()));
<a name="l01081"></a>01081     connect(buttonZoomOriginal,SIGNAL(clicked()),<span class="keyword">this</span>,SLOT(zoomOriginalClicked()));
<a name="l01082"></a>01082 
<a name="l01083"></a>01083 }
<a name="l01084"></a>01084 
<a name="l01085"></a>01085 <span class="keywordtype">void</span> QVCanvas::drawSelClicked(<span class="keywordtype">bool</span> checked) {
<a name="l01086"></a>01086     imageArea-&gt;drawSel = checked;
<a name="l01087"></a>01087     refreshImageArea();
<a name="l01088"></a>01088 }
<a name="l01089"></a>01089 
<a name="l01090"></a>01090 <span class="keywordtype">void</span> QVCanvas::zoomInClicked() {
<a name="l01091"></a>01091     imageArea-&gt;centerZoom(2*imageArea-&gt;zoom);
<a name="l01092"></a>01092 }
<a name="l01093"></a>01093 
<a name="l01094"></a>01094 <span class="keywordtype">void</span> QVCanvas::zoomOutClicked() {
<a name="l01095"></a>01095     imageArea-&gt;centerZoom(imageArea-&gt;zoom/2);
<a name="l01096"></a>01096 }
<a name="l01097"></a>01097 
<a name="l01098"></a>01098 <span class="keywordtype">void</span> QVCanvas::zoomOriginalClicked() {
<a name="l01099"></a>01099     <span class="comment">// (Tricky) force redraw at initial size:</span>
<a name="l01100"></a>01100     <span class="keywordtype">int</span> w = imageArea-&gt;origwidth, h = imageArea-&gt;origheight;
<a name="l01101"></a>01101     imageArea-&gt;origwidth = imageArea-&gt;origheight = 0;
<a name="l01102"></a>01102     QRect saveSelRect = imageArea-&gt;selRect;
<a name="l01103"></a>01103     <a class="code" href="classQVPolyline.html" title="Polyline representation.">QVPolyline</a> saveSelPoly = imageArea-&gt;selPoly;
<a name="l01104"></a>01104     imageArea-&gt;resizeImageArea(w,h);
<a name="l01105"></a>01105     imageArea-&gt;selRect = saveSelRect;
<a name="l01106"></a>01106     imageArea-&gt;selPoly = saveSelPoly;
<a name="l01107"></a>01107     refreshImageArea();
<a name="l01108"></a>01108 }
<a name="l01109"></a>01109 
<a name="l01110"></a>01110 
<a name="l01111"></a>01111 <span class="keywordtype">void</span> QVCanvas::zoomRectClicked(<span class="keywordtype">bool</span> checked) {
<a name="l01112"></a>01112     <span class="keywordflow">if</span>(checked)
<a name="l01113"></a>01113         imageArea-&gt;setCursor(Qt::CrossCursor);
<a name="l01114"></a>01114     <span class="keywordflow">else</span>
<a name="l01115"></a>01115         imageArea-&gt;setCursor(Qt::ArrowCursor);
<a name="l01116"></a>01116     imageArea-&gt;mouseMode = (checked ? QVImageArea::ZOOM : QVImageArea::NONE);
<a name="l01117"></a>01117     buttonselPoly-&gt;setChecked(<span class="keyword">false</span>);
<a name="l01118"></a>01118     buttonSelRect-&gt;setChecked(<span class="keyword">false</span>);
<a name="l01119"></a>01119     buttonDrag-&gt;setChecked(<span class="keyword">false</span>);
<a name="l01120"></a>01120 }
<a name="l01121"></a>01121 
<a name="l01122"></a>01122 <span class="keywordtype">void</span> QVCanvas::selPolyClicked(<span class="keywordtype">bool</span> checked) {
<a name="l01123"></a>01123     <span class="keywordflow">if</span>(checked)
<a name="l01124"></a>01124         imageArea-&gt;setCursor(Qt::CrossCursor);
<a name="l01125"></a>01125     <span class="keywordflow">else</span>
<a name="l01126"></a>01126         imageArea-&gt;setCursor(Qt::ArrowCursor);
<a name="l01127"></a>01127 
<a name="l01128"></a>01128     <span class="keywordflow">if</span> (checked) {
<a name="l01129"></a>01129         imageArea-&gt;mouseMode = QVImageArea::POLY;
<a name="l01130"></a>01130         imageArea-&gt;polyMode = polyMode;
<a name="l01131"></a>01131     } <span class="keywordflow">else</span> {
<a name="l01132"></a>01132         imageArea-&gt;mouseMode = QVImageArea::NONE;
<a name="l01133"></a>01133     }
<a name="l01134"></a>01134     buttonZoomRect-&gt;setChecked(<span class="keyword">false</span>);
<a name="l01135"></a>01135     buttonSelRect-&gt;setChecked(<span class="keyword">false</span>);
<a name="l01136"></a>01136     buttonDrag-&gt;setChecked(<span class="keyword">false</span>);
<a name="l01137"></a>01137 }
<a name="l01138"></a>01138 
<a name="l01139"></a>01139 <span class="keywordtype">void</span> QVCanvas::selPolyChangedToList() {
<a name="l01140"></a>01140     polyMode = LIST;
<a name="l01141"></a>01141     <span class="keywordflow">if</span>(imageArea-&gt;polyMode != LIST) {
<a name="l01142"></a>01142         imageArea-&gt;polyMode = polyMode;
<a name="l01143"></a>01143         imageArea-&gt;selPoly = <a class="code" href="classQVPolyline.html" title="Polyline representation.">QVPolyline</a>();
<a name="l01144"></a>01144         polySelectedSlot(QPoint(), <span class="keyword">true</span>, polyMode);
<a name="l01145"></a>01145         refreshImageArea();
<a name="l01146"></a>01146     }
<a name="l01147"></a>01147     buttonselPoly-&gt;setIcon(QIcon(<span class="stringliteral">&quot;:/images/list.png&quot;</span>));
<a name="l01148"></a>01148     selPolyClicked(<span class="keyword">true</span>);
<a name="l01149"></a>01149     buttonselPoly-&gt;setChecked(<span class="keyword">true</span>);
<a name="l01150"></a>01150 }
<a name="l01151"></a>01151 
<a name="l01152"></a>01152 <span class="keywordtype">void</span> QVCanvas::selPolyChangedToLine() {
<a name="l01153"></a>01153     polyMode = LINE;
<a name="l01154"></a>01154     <span class="keywordflow">if</span>(imageArea-&gt;polyMode != LINE) {
<a name="l01155"></a>01155         imageArea-&gt;polyMode = polyMode;
<a name="l01156"></a>01156         imageArea-&gt;selPoly = <a class="code" href="classQVPolyline.html" title="Polyline representation.">QVPolyline</a>();
<a name="l01157"></a>01157         polySelectedSlot(QPoint(), <span class="keyword">true</span>, polyMode);
<a name="l01158"></a>01158         refreshImageArea();
<a name="l01159"></a>01159     }
<a name="l01160"></a>01160     buttonselPoly-&gt;setIcon(QIcon(<span class="stringliteral">&quot;:/images/poly.png&quot;</span>));
<a name="l01161"></a>01161     selPolyClicked(<span class="keyword">true</span>);
<a name="l01162"></a>01162     buttonselPoly-&gt;setChecked(<span class="keyword">true</span>);
<a name="l01163"></a>01163 }
<a name="l01164"></a>01164 
<a name="l01165"></a>01165 <span class="keywordtype">void</span> QVCanvas::selPolyChangedToClosed() {
<a name="l01166"></a>01166     polyMode = CLOSED;
<a name="l01167"></a>01167     <span class="keywordflow">if</span>(imageArea-&gt;polyMode != CLOSED) {
<a name="l01168"></a>01168         imageArea-&gt;polyMode = polyMode;
<a name="l01169"></a>01169         imageArea-&gt;selPoly = <a class="code" href="classQVPolyline.html" title="Polyline representation.">QVPolyline</a>();
<a name="l01170"></a>01170         polySelectedSlot(QPoint(), <span class="keyword">true</span>, polyMode);
<a name="l01171"></a>01171         refreshImageArea();
<a name="l01172"></a>01172     }
<a name="l01173"></a>01173     buttonselPoly-&gt;setIcon(QIcon(<span class="stringliteral">&quot;:/images/polyclosed.png&quot;</span>));
<a name="l01174"></a>01174     selPolyClicked(<span class="keyword">true</span>);
<a name="l01175"></a>01175     buttonselPoly-&gt;setChecked(<span class="keyword">true</span>);
<a name="l01176"></a>01176 }
<a name="l01177"></a>01177 
<a name="l01178"></a>01178 <span class="keywordtype">void</span> QVCanvas::selRectClicked(<span class="keywordtype">bool</span> checked) {
<a name="l01179"></a>01179     <span class="keywordflow">if</span>(checked)
<a name="l01180"></a>01180         imageArea-&gt;setCursor(Qt::CrossCursor);
<a name="l01181"></a>01181     <span class="keywordflow">else</span>
<a name="l01182"></a>01182         imageArea-&gt;setCursor(Qt::ArrowCursor);
<a name="l01183"></a>01183     imageArea-&gt;mouseMode = (checked ? QVImageArea::SEL : QVImageArea::NONE);
<a name="l01184"></a>01184     buttonZoomRect-&gt;setChecked(<span class="keyword">false</span>);
<a name="l01185"></a>01185     buttonselPoly-&gt;setChecked(<span class="keyword">false</span>);
<a name="l01186"></a>01186     buttonDrag-&gt;setChecked(<span class="keyword">false</span>);
<a name="l01187"></a>01187     <span class="keywordflow">if</span> (!checked) {
<a name="l01188"></a>01188         imageArea-&gt;selRect = QRect();
<a name="l01189"></a>01189         refreshImageArea();
<a name="l01190"></a>01190         emit imageArea-&gt;rectSelected(QRect());
<a name="l01191"></a>01191     }
<a name="l01192"></a>01192 }
<a name="l01193"></a>01193 
<a name="l01194"></a>01194 <span class="keywordtype">void</span> QVCanvas::dragClicked(<span class="keywordtype">bool</span> checked) {
<a name="l01195"></a>01195     <span class="keywordflow">if</span>(checked)
<a name="l01196"></a>01196         imageArea-&gt;setCursor(Qt::OpenHandCursor);
<a name="l01197"></a>01197     <span class="keywordflow">else</span>
<a name="l01198"></a>01198         imageArea-&gt;setCursor(Qt::ArrowCursor);
<a name="l01199"></a>01199 
<a name="l01200"></a>01200     imageArea-&gt;mouseMode = (checked ? QVImageArea::DRAG : QVImageArea::NONE);
<a name="l01201"></a>01201     buttonselPoly-&gt;setChecked(<span class="keyword">false</span>);
<a name="l01202"></a>01202     buttonSelRect-&gt;setChecked(<span class="keyword">false</span>);
<a name="l01203"></a>01203     buttonZoomRect-&gt;setChecked(<span class="keyword">false</span>);
<a name="l01204"></a>01204 }
<a name="l01205"></a>01205 
<a name="l01206"></a>01206 
<a name="l01207"></a>01207 <span class="keywordtype">void</span> QVCanvas::newMousePositionSlot(<span class="keywordtype">float</span> x,<span class="keywordtype">float</span> y) {
<a name="l01208"></a>01208     mousePosX = x;
<a name="l01209"></a>01209     mousePosY = y;
<a name="l01210"></a>01210     statusBar-&gt;showMessage(statusMessage());
<a name="l01211"></a>01211 }
<a name="l01212"></a>01212 
<a name="l01213"></a>01213 <span class="keywordtype">void</span> QVCanvas::mouseLeavesImageAreaSlot(<span class="keywordtype">bool</span> leaves) {
<a name="l01214"></a>01214 <span class="comment">/*      if(leaves)</span>
<a name="l01215"></a>01215 <span class="comment">        std::cout &lt;&lt; &quot;SALGO-----------------------------&quot; &lt;&lt; std::endl;</span>
<a name="l01216"></a>01216 <span class="comment">    else</span>
<a name="l01217"></a>01217 <span class="comment">        std::cout &lt;&lt; &quot;ENTRO-----------------------------&quot; &lt;&lt; std::endl;*/</span>
<a name="l01218"></a>01218     mouseIsOut = leaves;
<a name="l01219"></a>01219     statusBar-&gt;showMessage(statusMessage());
<a name="l01220"></a>01220 }
<a name="l01221"></a>01221 
<a name="l01222"></a>01222 
<a name="l01223"></a>01223 QVCanvas::~QVCanvas()
<a name="l01224"></a>01224 {
<a name="l01225"></a>01225 <span class="preprocessor">    #ifdef QVQWT</span>
<a name="l01226"></a>01226 <span class="preprocessor"></span>    <span class="keyword">delete</span> scaleEngineX;
<a name="l01227"></a>01227     <span class="keyword">delete</span> scaleEngineY;
<a name="l01228"></a>01228 <span class="preprocessor">    #endif</span>
<a name="l01229"></a>01229 <span class="preprocessor"></span>
<a name="l01230"></a>01230     <span class="comment">// It remove its reference of the image areas list</span>
<a name="l01231"></a>01231     image_areas.removeAll(imageArea);
<a name="l01232"></a>01232 
<a name="l01233"></a>01233     <span class="keyword">delete</span> imageArea;
<a name="l01234"></a>01234 }
<a name="l01235"></a>01235 
<a name="l01236"></a>01236 <span class="keywordtype">void</span> QVCanvas::refreshImageArea()
<a name="l01237"></a>01237 {
<a name="l01238"></a>01238     imageArea-&gt;makeCurrent();
<a name="l01239"></a>01239     imageArea-&gt;update();
<a name="l01240"></a>01240 }
<a name="l01241"></a>01241 
<a name="l01242"></a>01242 
<a name="l01243"></a>01243 <span class="keywordtype">void</span> QVCanvas::setGeometry(<span class="keywordtype">int</span> origwidth,<span class="keywordtype">int</span> origheight,<span class="keywordtype">int</span> topleftx,<span class="keywordtype">int</span> toplefty,<span class="keywordtype">int</span> width,<span class="keywordtype">int</span> height, <span class="keywordtype">int</span> zoom)
<a name="l01244"></a>01244 {
<a name="l01245"></a>01245     Q_UNUSED(origwidth);
<a name="l01246"></a>01246     Q_UNUSED(origheight);
<a name="l01247"></a>01247 
<a name="l01248"></a>01248     QFontMetrics fm(font());
<a name="l01249"></a>01249 
<a name="l01250"></a>01250     <span class="comment">// virtual QwtScaleDiv divideScale(double x1, double x2,</span>
<a name="l01251"></a>01251     <span class="comment">//     int numMajorSteps, int numMinorSteps, double stepSize=0.0) const</span>
<a name="l01252"></a>01252 <span class="preprocessor">    #ifdef QVQWT</span>
<a name="l01253"></a>01253 <span class="preprocessor"></span>    QwtScaleDiv scaleDivX = scaleEngineX-&gt;divideScale(
<a name="l01254"></a>01254                     ((<span class="keywordtype">double</span>)topleftx)/zoom,((<span class="keywordtype">double</span>)(topleftx+width))/zoom,
<a name="l01255"></a>01255                     qMin(width/zoom+1,static_cast&lt;int&gt;(width/(fm.width(<span class="stringliteral">&quot;999&quot;</span>)))),
<a name="l01256"></a>01256                     10,0);
<a name="l01257"></a>01257     scaleWidgetX-&gt;setScaleDiv(scaleEngineX-&gt;transformation(),scaleDivX);
<a name="l01258"></a>01258 
<a name="l01259"></a>01259     QwtScaleDiv scaleDivY = scaleEngineY-&gt;divideScale(
<a name="l01260"></a>01260                     ((<span class="keywordtype">double</span>)toplefty+height)/zoom,((<span class="keywordtype">double</span>)(toplefty))/zoom,
<a name="l01261"></a>01261                     qMin(height/zoom+1,static_cast&lt;int&gt;(height/(fm.width(<span class="stringliteral">&quot;999&quot;</span>)))),
<a name="l01262"></a>01262                     10,0);
<a name="l01263"></a>01263     scaleWidgetY-&gt;setScaleDiv(scaleEngineY-&gt;transformation(),scaleDivY);
<a name="l01264"></a>01264 
<a name="l01265"></a>01265     <span class="comment">// Left and right (top &amp; bottom) scaleWidgetsFixedWidth for scale widgets</span>
<a name="l01266"></a>01266     <span class="comment">// (Otherwise, setBorderDist does not work!);</span>
<a name="l01267"></a>01267 
<a name="l01268"></a>01268     scaleWidgetX-&gt;setGeometry(0,0,
<a name="l01269"></a>01269         2*scaleWidgetsFixedWidth+width+1,scaleWidgetsFixedWidth);
<a name="l01270"></a>01270     scaleWidgetY-&gt;setGeometry(0,0,
<a name="l01271"></a>01271         scaleWidgetsFixedWidth,2*scaleWidgetsFixedWidth+height+1);
<a name="l01272"></a>01272 <span class="preprocessor">    #endif</span>
<a name="l01273"></a>01273 <span class="preprocessor"></span>
<a name="l01274"></a>01274     setMinimumSize(scaleWidgetsFixedWidth + imageArea-&gt;minimumWidth() + 1,
<a name="l01275"></a>01275                    scaleWidgetsFixedWidth + imageArea-&gt;minimumHeight() + 1 +
<a name="l01276"></a>01276                    statusBarWidgetFixedHeight);
<a name="l01277"></a>01277 
<a name="l01278"></a>01278     setMaximumSize(scaleWidgetsFixedWidth+zoom*imageArea-&gt;origwidth + 1 +1,
<a name="l01279"></a>01279                    scaleWidgetsFixedWidth+zoom*imageArea-&gt;origheight + 1 +
<a name="l01280"></a>01280                    statusBarWidgetFixedHeight + 1);
<a name="l01281"></a>01281 
<a name="l01282"></a>01282     resize(scaleWidgetsFixedWidth+width+1,
<a name="l01283"></a>01283             scaleWidgetsFixedWidth+height+1+statusBarWidgetFixedHeight);
<a name="l01284"></a>01284 
<a name="l01285"></a>01285     statusBar-&gt;setGeometry(
<a name="l01286"></a>01286         0,scaleWidgetsFixedWidth+height+1,
<a name="l01287"></a>01287         scaleWidgetsFixedWidth+width+1,statusBarWidgetFixedHeight);
<a name="l01288"></a>01288 
<a name="l01289"></a>01289     statusBar-&gt;showMessage(statusMessage());
<a name="l01290"></a>01290 }
<a name="l01291"></a>01291 <span class="comment">// #endif //DOXYGEN_IGNORE_THIS</span>
<a name="l01292"></a>01292 
</pre></div></div>
</td></tr></table>

<br /><hr><br />
<center><a href="http://perception.inf.um.es/QVision">QVision framework</a>.
<a href="http://perception.inf.um.es">PARP research group</a>.
Copyright &copy; 2007, 2008, 2009, 2010, 2011.</center>
<br />
</body>
</html>
